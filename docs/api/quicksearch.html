<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"request_plugin_BasePlugin.js.html":{"id":"request_plugin_BasePlugin.js.html","title":"Source: request/plugin/BasePlugin.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: request/plugin/BasePlugin.js export default class BasePlugin { pluginName = ''; //插件名称，主要用于打印日志和调试，便于追溯操作源 requester = null; constructor({pluginName}){ this.pluginName = pluginName || this.pluginName; if (!this.pluginName) { console.warn('[requester plugin] 建议为插件设置一个pluginName，便于出现问题时排查追溯：',this); } } /** * 钩子函数，插件被挂载到requester对象上时被调用 * @param {Requester} requester 请求管理器 */ mount({requester}){ this.requester = requester; } /** * 钩子函数，发请求之前调用，同步 * 不会等待异步操作返回，如需等待异步逻辑，请改用beforeRequestAsync * @param {Object} reqOptions 请求参数 * @param {*} thisIssuer 发起请求的this对象 * @return {undefined | {action: string, errMsg: string}} 期望的后续处理： * undefined - 默认 * { * action: '', //后续处理：'cancel'-终止该请求 | 'continue'-继续发送 * errMsg: '', //错误信息，解释拦截原因 * } * @example beforeRequest({reqOptions, thisIssuer}){ return { action: 'continue', errMsg: 'ok', } } */ beforeRequest({reqOptions, thisIssuer}){}; /** * 钩子函数，发请求之前调用，异步 * 会等待async函数resolve，若无异步逻辑，建议使用beforeRequest * @param {Object} reqOptions 请求参数 * @param {*} thisIssuer 发起请求的this对象 * @return {Promise&lt;undefined | {action: 'cancel'|'continue', errMsg: string}&gt;} 期望的后续处理： * undefined - 默认 * { * action: '', //后续处理：'cancel'-终止该请求 | 'continue'-继续发送 * errMsg: '', //错误信息，解释拦截原因 * } * @example async beforeRequestAsync({reqOptions, thisIssuer}){ return { action: 'continue', errMsg: 'ok', } } */ beforeRequestAsync({reqOptions, thisIssuer}){}; /** * 钩子函数，请求返回之后调用，同步 * 不会等待异步操作返回，如需等待异步逻辑，请改用afterRequestAsync * @param {Object} reqOptions 请求参数 * @param {*} thisIssuer 发起请求的this对象 * @param {RequestRes} reqRes 请求返回结果，除单独说明字段外，格式同wx.request回调结果 * @param {boolean} reqRes.succeeded 请求成功/失败 * @return {undefined | {action: string, errMsg: string, overrideRes: RequestRes}} 期望的后续处理： * undefined - 默认 * { * action: '', //后续处理：'continue'-继续 | 'override'-覆盖请求结果 | 'retry'-重新发送请求 * overrideRes: {}, //action==='override'时，以该结果覆盖原来的请求结果 * errMsg: '', //错误信息，解释操作原因，便于定位追溯 * } * @example afterRequest({reqOptions, thisIssuer}){ return { action: 'continue', errMsg: 'ok', } } */ afterRequest({reqOptions, thisIssuer, reqRes}){}; /** * 钩子函数，请求返回之后调用，异步 * 会等待async函数resolve，若无异步逻辑，建议使用afterRequest * @param {Object} reqOptions 请求参数 * @param {*} thisIssuer 发起请求的this对象 * @param {RequestRes} reqRes 请求返回结果，除单独说明字段外，格式同wx.request回调结果 * @param {boolean} reqRes.succeeded 请求成功/失败 * @return {Promise&lt;undefined | {action: string, errMsg: string, overrideRes: RequestRes}&gt;} 期望的后续处理： * undefined - 默认 * { * action: '', //后续处理：'continue'-继续 | 'override'-覆盖请求结果 | 'retry'-重新发送请求 * overrideRes: {}, //action==='override'时，以该结果覆盖原来的请求结果 * errMsg: '', //错误信息，解释操作原因，便于定位追溯 * } * @example async afterRequestAsync({reqOptions, thisIssuer}){ return { action: 'continue', errMsg: 'ok', } } */ afterRequestAsync({reqOptions, thisIssuer, reqRes}){}; } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"operationKit.js.html":{"id":"operationKit.js.html","title":"Source: operationKit.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: operationKit.js /** * 封装常用的通用功能函数 */ /** * 深度拷贝 * @param source 源参数 * @return {*} 源参数的深度拷贝 */ export function deepClone(source){ if (!isNonNullObject(source)) return source; var clone = Array.isArray(source) ? [] : {}; for (var p in source) clone[p] = deepClone(source[p]); return clone; } /** * 深度判等 * 两个对象结构和数据完全一致，即认为相等，而不要求是同一引用 * @param o1 参数1 * @param o2 参数2 * @return {boolean} 参数1、参数2 是否相等 */ export function deepEqual(o1, o2) { if (!( isNonNullObject(o1) &amp;&amp; isNonNullObject(o2) )) return o1 === o2; for (var p in o1) { if (!deepEqual(o1[p], o2[p])) return false; } for (var q in o2) { if (!(q in o1)) return false; } return true; } /** * 深度覆盖 * 将源对象的值覆盖目标对象，相同结构相同参数部分直接覆盖，其它部分保持不变 * @param target 目标对象 * @param sources 若干个源对象 * * @example * 修改前： * target = {x: 1, y: {a: 1, b:1 }, z: 1}; * source = {x: 2, y: {a: 2}}; * * 修改后： * target = {x: 2, y: {a: 2, b:1 }, z: 1} */ export function deepAssign(target, ...sources) { if (!isNonNullObject(target)) { console.error('[deepAssign] bad parameters, target should be an object, parameters:', arguments); return target; } for (let source of sources) { if (source === null || source === undefined) continue; if (typeof source !== \"object\") { console.warn('[deepAssign] bad parameters, source should all be object, parameters:', arguments); continue; } for (var p in source) { if (isNonNullObject(target[p]) &amp;&amp; typeof source[p] === \"object\") deepAssign(target[p], source[p]); else target[p] = source[p]; } } return target; } /** * 覆盖目标字段，剔除多余字段 * 将源对象的值覆盖目标对象，相同结构相同参数部分直接覆盖，其它部分予以剔除 * @param {object} target 目标对象 * @param {object} sources 若干个源对象 * * @example //模块中指定的可配项列表及其默认值 const defaultOptions = { x: 1, y: {a: 1, b: 1} }; //调用方传入的自定义配置 let customOptions = { y: {a: 2}, //可能只指定了部分配置 zz: 2, //可能还含有一堆杂七杂八的属性 zzz: 2, }; //初始配置（target为空对象时，取source[0]作为蓝本，只保留sources[0]中的属性） let options = peerAssign({}, defaultOptions, customOptions); console.log('options:', options); //{x: 1, y: {a:2, b:1}} 所需属性予以覆盖，多余属性予以剔除 //增量配置（target不为空时，取target作为蓝本，只保留target中的属性） peerAssign(options, {x:3, y: {b:3}, zz:3}); console.log('options:', options); //{x: 3, y: {a:2, b:3}} */ export function peerAssign(target, ...sources) { if (!isNonNullObject(target)) { console.error('[peerAssign] bad parameters, target should be an object, got:', target, 'sources:', ...sources); return target; } let blueprint = isNonEmptyObject(target) ? target : (sources[0] || {}); for (let source of sources) { if (source === null || source === undefined) continue; if (typeof source !== \"object\") { console.warn('[peerAssign] bad parameters, source should all be object, parameters:', arguments); continue; } for (let p in blueprint) { if (!(p in source)) continue; if (isNonEmptyObject(blueprint[p])) { //蓝本中为非空对象，只保留蓝本中指定的字段 target[p] = target[p] || {}; peerAssign(target[p], source[p]); } else if (isNonNullObject(blueprint[p])) { //蓝本中为空对象，接受任意字段 target[p] = target[p] || {}; deepAssign(target[p], source[p]); } else { //其它情况，直接覆盖 target[p] = source[p]; } } } return target; } /** * 判断一个变量是否为非null对象 * @param item * @return {boolean} */ export function isNonNullObject(item) { return typeof item === \"object\" &amp;&amp; item !== null; } /** * 判断一个变量是否为非空对象 * @param item * @return {boolean} */ export function isNonEmptyObject(item) { return isNonNullObject(item) &amp;&amp; Object.getOwnPropertyNames(item).length&gt;0; } /** * 设置延时 * @param {number} ms 延迟时长，单位：ms * @return {Promise} */ export function delay(ms) { return new Promise((resolve, reject)=&gt;{ setTimeout(resolve, ms); }); } /** * 版本号比较 * @param {string} v1 版本号1，形如\"2.2.3\" * @param {string} v2 版本号2 * @return {number} 比较结果： -1 小于 | 0 等于 | 1 大于 */ export function compareVersion(v1, v2) { var seq1 = v1.split(\".\").map(subVersion=&gt;parseInt(subVersion)); var seq2 = v2.split(\".\").map(subVersion=&gt;parseInt(subVersion)); var len1 = seq1.length, len2 = seq2.length, commonLen = Math.min(len1, len2); for (var i=0; i&lt;commonLen; ++i) { if (seq1[i] != seq2[i]) return seq1[i]&lt;seq2[i] ? -1 : 1; } return len1==len2 ? 0 : (len1&lt;len2 ? -1 : 1); } /** * 拼接参数，注：当前只针对小程序标准url，暂未考虑含#号/多?号等特殊url情形 * @param {string} url 原url * @param {Object} extraParams 新增参数 * @return {string} 新url */ export function appendUrlParam(url, extraParams) { if (!extraParams) return url; let [path, queryStr=\"\"] = url.split('?'); let params = {}; queryStr.split('&amp;').forEach(paramStr=&gt;{ let [name, value] = paramStr.split('='); if (name &amp;&amp; value!==undefined) params[name] = value; }); let newParams = Object.assign({}, params, extraParams); let newQueries = []; for (let name in newParams) newQueries.push(name + '=' + newParams[name]); return newQueries.length&gt;0 ? path + '?' + newQueries.join('&amp;') : url; } /** * 将小程序相对路径转为绝对路径 * @param {string} relativePath 相对路径 * @param {string} curPath 当前路径 * @return {string} 绝对路径 */ export function toAbsolutePath(relativePath, curPath) { if (!(typeof relativePath === 'string' &amp;&amp; typeof curPath === 'string') ) { console.error('[toAbsolutePath] bad params, relativePath:', relativePath, 'curPath:', curPath); return relativePath; } if (relativePath[0] === '/') //已经是绝对路径 return relativePath; let levels = curPath.split('/').slice(0,-1).concat(relativePath.split('/')); let absoluteLevels = []; for (let level of levels) { if (level === '' || level==='.') continue; if (level === '..'){ absoluteLevels.pop(); continue; } absoluteLevels.push(level); } return '/'+absoluteLevels.join('/'); } /** * 剩余时间的语义化表示 * @param {number} remainMs 剩余时间，单位：毫秒 * @param {number} remainderInterval 最小时间间隔，不足1秒的部分以此计数 * @param {string} topLevel 顶层间隔：day|hour|minute|second， 如顶层间隔为'hour'，则返回结果为形如 27小时3分钟 而不是 1天3小时3分钟 * @return {{days: number, hours: number, minutes: number, seconds: number, remainderIntervals: number}} 剩余days天hours小时minutes分钟seconds秒remainderIntervals间隔 */ export function semanticRemainTime({remainMs, topLevel='day', remainderInterval=1000}) { const SCALES = { second: 1000, minute: 60*1000, hour: 60*60*1000, day: 24*60*60*1000, }; let topScale = SCALES[topLevel]; let [days, hours, minutes, seconds, remainderIntervals] = [ SCALES.day, SCALES.hour, SCALES.minute, SCALES.second, remainderInterval ].map((scale, idx, arr)=&gt;{ return (scale&gt;=topScale || idx===0) ? remainMs/scale : remainMs%arr[idx-1]/scale }).map(Math.floor); return { days, hours, minutes, seconds, remainderIntervals } } /** * 若字符串长度小于指定长度，则在前方拼接指定字符 * es6中string的padStart函数目前存在兼容性问题，暂以此替代 * @param str 字符串 * @param minLen 指定长度 * @param leadChar 指定字符 * @return {string} 新字符串 */ export function padStart(str, minLen, leadChar) { str = String(str); while (str.length &lt; minLen) str = leadChar+str; return str; } /** * 查询元素在页面中的坐标，单位：px * @param {string} selector 元素选择器 * @return {Promise&lt;Object&gt;} 元素坐标 */ export async function queryRect(selector){ return new Promise((resolve, reject)=&gt;{ wx.createSelectorQuery().select(selector).boundingClientRect(resolve).exec(); }); } /** * 将内联样式字符串解析为对象形式 * @param {string} styleStr 内联样式，e.g. 'color: red; transform: translate(20px, 30px)' * @return {Object} 内联样式对象，e.g. {color:\"red\",transform:\"translate(20px, 30px)\"} */ export function parseInlineStyle(styleStr) { if (!styleStr) return {}; let styleObj = {}; let declarations = styleStr.split(';'); for (let declaration of declarations) { let [prop, value] = declaration.split(':').map(part=&gt;part.replace(/^\\s*|\\s*$/g, '')); styleObj[prop] = value; } return styleObj; } /** * 将样式对象转为内联样式字符串 * @param {Object} styleObj 内联样式对象，e.g. {color:\"red\",transform:\"translate(20px, 30px)\"} * @return {string} 内联样式，e.g. 'color: red; transform: translate(20px, 30px)' */ export function toInlineStyle(styleObj) { let declarations = []; for (let prop in styleObj) declarations.push(`${prop}:${styleObj[prop]}`); return declarations.join('; '); } /** * 将实例方法封装为通用函数，使之可以在任何this对象上执行 * @param {Object} instance 实例对象 * @param {String} method 方法名 * @param {Object|Boolean} [rcvThis] 保存触发源的this对象 * @param {Number} [rcvThis.argIdx] 将this对象保存到下标为argIdx的参数的argProp属性上 * @param {String} [rcvThis.argProp] 将this对象保存到下标为argIdx的参数的argProp属性上 */ export function makeAssignableMethod({instance, method, rcvThis}) { //无需记录触发源this对象，直接绑定this，返回 if (!rcvThis) return instance[method].bind(instance); //参数处理 const defaultRcv = { argIdx: 0, argProp: 'thisIssuer' }; rcvThis = typeof rcvThis === \"object\" ? rcvThis : {}; rcvThis = Object.assign({}, defaultRcv, rcvThis); //封装函数 return function (...args) { //记录触发源this对象 args[rcvThis.argIdx] = args[rcvThis.argIdx] || {}; args[rcvThis.argIdx][rcvThis.argProp] = args[rcvThis.argIdx][rcvThis.argProp] || this; //将this重置为指定实例 return instance[method].apply(instance, args); } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"login_auth_BaseAuth.js.html":{"id":"login_auth_BaseAuth.js.html","title":"Source: login/auth/BaseAuth.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: login/auth/BaseAuth.js export default class BaseAuth { /** * 静默登录 * 可以在用户无感知的情况下后台悄悄完成的登录过程 * @param {Object} loginOptions 登录函数调用参数 * @param {Object} configOptions 登录模块配置参数 * @return {Promise&lt;{succeeded: boolean, errMsg: string, userInfo: {}, expireTime: number, anonymousInfo: {}}&gt;} */ silentLogin({loginOptions, configOptions}){ return { succeeded: false, //是否成功 errMsg: '该授权方式未实现静默登录', //详细错误信息，调试用 toastMsg: '该授权方式未实现静默登录', //（若有）错误信息话术，展示给用户 userInfo: {}, //（成功时）用户信息 expireTime: -1, //（成功时）过期时间，绝对毫秒数，-1表示长期有效 anonymousInfo: null, //（不管成功失败）匿名信息，登录成功前使用的临时标识，成功后继续关联 } } /** * 进行授权登录之前的准备工作 * 时序：beforeAuthLogin -&gt; 用户交互，同意授权 -&gt; authLogin * @param {Object} loginOptions 登录函数调用参数 * @param {Object} configOptions 登录模块配置参数 * @return {Promise&lt;*&gt;} 需要传递给authLogin的数据 */ beforeAuthLogin({loginOptions, configOptions}){}; /** * 授权登录 * 需要用户配合点击授权按钮/输入表单等才能完成的登录过程 * @param {Object} loginOptions 登录函数调用参数 * @param {Object} configOptions 登录模块配置参数 * @param {*} [beforeRes] beforeAuthLogin钩子执行结果 * @param {Object} authData 登录界面交互结果 * @return {Promise&lt;{succeeded: boolean, errMsg: string, userInfo: {}, expireTime: number, anonymousInfo: {}}&gt;} */ authLogin({loginOptions, configOptions, beforeRes, authData}){ return { succeeded: false, //是否成功 errMsg: '该授权方式未实现授权登录', //详细错误信息，调试用 toastMsg: '该授权方式未实现授权登录', //（若有）错误信息话术，展示给用户 userInfo: {}, //（成功时）用户信息 expireTime: -1, //（成功时）过期时间，绝对毫秒数，-1表示长期有效 anonymousInfo: null, //（不管成功失败）匿名信息，登录成功前使用的临时标识，成功后继续关联 } } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"navigate_History.js.html":{"id":"navigate_History.js.html","title":"Source: navigate/History.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: navigate/History.js import {deepClone} from '../operationKit'; /** * 历史记录 * 由于小程序只支持最多5级页面，但需求上希望维护更长的历史栈，故自行维护完整历史记录 */ export default class History { _routes = []; //历史栈 _correctLevel = 1; //自行维护的逻辑历史栈与系统实际历史栈的前若干项应当始终保持一致 constructor({routes=[]}){ this._routes = routes.slice(0); } config({correctLevel=1}={}){ this._correctLevel = correctLevel; } /** * wepy框架存在单实例问题，同一路径页面被打开两次时，其数据会相互影响,，如：详情页A - 详情页B - 返回A，点击查看大图 - B的图片（而不是A的图片） * 故需检查历史页面实例是否已被覆盖，若已被覆盖，则返回时需手动刷新 * @private */ _checkTainted(){ for (let i=0; i&lt;this._routes.length; ++i) { if (this._routes[i].tainted) continue; let tainted = false; for (let j=i+1; j&lt;this._routes.length; ++j) { if (isSamePage(this._routes[i].url, this._routes[j].url)) { //判断页面实例是否被后续实例覆盖 tainted = true; break; } } this._routes[i].tainted = tainted; } } /** * 打开新页面 * @param {Object} route 页面配置 */ open(route){ this.doCorrection(); this._routes.push(Object.assign({}, route)); this._checkTainted(); } /** * 替换当前页 * @param {Object} route 页面配置 */ replace(route){ this.doCorrection(); this._routes[this._routes.length-1] = Object.assign({}, route); this._checkTainted(); } /** * 返回 * @param {Number} delta 返回级数 * @return {Object} 返回完成后所处的页面配置 */ back({delta=1}={}){ this.doCorrection(); this._routes.length = Math.max(this._routes.length-delta, 0); return this.curRoute; } /** * 根据系统历史栈校正本地维护的历史记录 * 考虑到实际路由场景过于复杂，故定期校正以增强健壮性，如：点击右上角主页按钮、退出后又点击另一个分享链接、页面未使用封装接口等 */ doCorrection(){ let curPages = getCurrentPages(); if (curPages.length &lt;= this._correctLevel) { let remainCorrect = this._routes.length===curPages.length &amp;&amp; curPages.every((page, idx)=&gt; isSamePage(fullUrl(page.route||page.__route__, page.options), this._routes[idx].url)); if (!remainCorrect) { this._routes = curPages.map(page=&gt;Object.assign(resetRoute({}), {url: fullUrl(page.route||page.__route__, page.options)})); this._checkTainted(); } } } /** * 保存页面数据 * @param {number} idx 页面栈下标 * @param {object} wxPage 原生页面实例 */ savePage(idx, wxPage){ this._routes[idx].wxPage = wxPage; } getRoute(idx){ if (!(idx&gt;=0 &amp;&amp; idx&lt;this._routes.length)) return resetRoute({}); let route = deepClone(this._routes[idx]); if (idx+1&lt;=this._correctLevel) route.wxPage = getCurrentPages()[idx]; return route; } /** * 历史栈长度 * @return {Number} */ get length(){ return this._routes.length; } /** * 当前页面配置 * @return {*} */ get curRoute(){ return this.getRoute(this._routes.length-1); } /** * 完整历史记录 * @return {Array} */ get routes(){ this.doCorrection(); return this._routes.map((val, idx)=&gt;this.getRoute(idx)); } /** * 自行维护的逻辑历史栈与系统实际历史栈的前若干项应当始终保持一致 * @return {number} */ get correctLevel(){ return this._correctLevel; } } /** * 将路径和参数拼成完整url * @param path 路径 * @param options 参数 * @return {string} url */ function fullUrl(path='', options={}) { let url = path[0]==='/' ? path : '/'+path; let params = []; for (let name in options) { params.push(name+'='+options[name]); } url += params.length &gt; 0 ? '?' : ''; url += params.join('&amp;'); return url; } /** * 判断两个url是否为同一个页面的实例 * @param url1 * @param url2 * @return {boolean} */ function isSamePage(url1='', url2='') { return url1.split('?')[0] === url2.split('?')[0]; } /** * 重置路由对象 * @param route */ function resetRoute(route={}) { route.url = ''; route.tainted = false; return route; } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"login_BaseLogin.js.html":{"id":"login_BaseLogin.js.html","title":"Source: login/BaseLogin.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: login/BaseLogin.js import {deepClone, makeAssignableMethod, peerAssign} from '../operationKit'; import {mergingStep, errSafe} from '../decorators'; /** * 登录模块 */ @requireConfig //确保调用API时已完成模块配置 class BaseLogin { //配置，格式参见config函数 _configOptions = {}; //数据（长期数据，会被存储到storage中） _loginInfo = { userInfo: {}, //用户信息 isLogin: false, //是否已登录 expireTime: -1, //过期时间，相对1970年的绝对毫秒数，-1表示长期有效 authType: '', //使用的验证方式 anonymousInfo: {}, //匿名信息（登录成功前使用的临时标识，成功后继续关联） }; //状态（短期数据，仅本次会话使用） _stateInfo = { isConfigReady: false, //是否已完成模块配置 }; /** * 构造函数 * @param {object} [configOptions] 配置项，格式参见config函数 */ constructor(configOptions){ configOptions &amp;&amp; this.config(configOptions); } /** * 模块配置 * @param {Object} configOptions * @param {String} [configOptions.loginInfoStorage] 登录相关信息存储到storage时使用的key * @param {Requester} configOptions.requester 请求管理器，为Requester对象（参见/src/request/Requester） * @param {Function} [configOptions.onUserAuthFailed] 钩子函数，获取用户授权信息失败时触发 * @param {Function} [configOptions.onUserAuthSucceeded] 钩子函数，获取用户授权信息成功时触发 * @param {Function} [configOptions.onNewlyLogin] 钩子函数，刚刚登录成功时触发（未登录=&gt;已登录） * @param {Function} [configOptions.onLoginFailed] 钩子函数，登录失败时触发 入参： 参数0：登录结果，格式形如：{ code: 0, //状态码，0为成功，其它为失败 errMsg:'login api failed...', //详细错误日志，debug用 toastMsg: '您的账号存在安全风险，请联系客服进行处理' //（若有）用户话术，提示失败原因 } 参数1：选项，格式形如：{ failAction: 'auto', //调用方希望的失败处理方式：auto-自动处理 | none-调用方自行处理 | 其它约定值 } * @param {Object} configOptions.authEngineMap 鉴权器映射表 key为登录方式，value为对应的鉴权器（BaseAuth对象，参见/src/login/auth/BaseAuth） e.g. { 'wechat' : new WechatAuth(), //微信登录，WechatAuth应继承于BaseAuth 'phone' : new PhoneAuth(), //手机号登录，PhoneAuth应继承于BaseAuth } * @param {String} configOptions.defaultAuthType 默认登录方式 * @param {Function} configOptions.userAuthHandler 授权交互处理函数（async），负责跟用户交互，收集鉴权所需信息 入参：无 返回值：形如 { succeeded: true, //是否成功 errMsg: '', //错误信息，调试用 authType: '', //用户选择的登录方式 authData: {}, //交互数据，格式由该登录方式对应的鉴权器指定 } * @param {Function} [configOptions.loginStepAddOn] 登录流程自定义附加步骤，为一个async函数，会在正常登录流程执行成功时调用，并根据其处理结果生成最终登录结果 入参：无 处理结果，格式形如：{ succeeded: true, //是否成功 errMsg:'login api failed...', //详细失败原因，debug用 toastMsg: '您的账号存在安全风险，请联系客服进行处理' //（若有）用户话术，提示失败原因 } */ config(configOptions){ //参数校验 const necessaryFields = ['userAuthHandler', 'authEngineMap', 'defaultAuthType', 'requester']; for (let field of necessaryFields) { if (configOptions[field] === undefined) { console.error('[Login] config, 必填参数缺失：', field); return; } } //参数处理 const defaultOpts = { loginInfoStorage: '__loginInfo', requester: null, onUserAuthFailed: null, onUserAuthSucceeded: null, onNewlyLogin: null, onLoginFailed(res, {failAction}){ switch (failAction) { //调用方希望的失败处理方式 case 'auto': //自动处理 wx.showToast({ title: res.toastMsg || '登录失败', image: '/images/tipfail.png', duration: 3000 }); break; case 'none': //调用方自行处理 break; default: console.error('[onLoginFailed] unknown failAction:', failAction); } }, authEngineMap: {}, //key: authType, value: BaseAuth defaultAuthType: '', userAuthHandler: null, loginStepAddOn: null, }; Object.assign(this._configOptions, peerAssign({}, defaultOpts, configOptions)); //初始化 this._init(); //标记状态 this._stateInfo.isConfigReady = true; } /** * 追加配置项 * 主要供子类调用，便于子类传递自定义配置项给自定义鉴权器/自定义钩子函数 * 建议子类将所有自定义配置项封装成一个对象，总共占用一个key，避免未来和父类新增配置项命名冲突 * @param {string} key 配置项名称 * @param {object|*} value 配置项值 * @protected */ _appendConfig(key, value){ if (key in this._configOptions) { console.error('[BaseLogin] _appendConfig, 新增配置项与已有配置项命名冲突：', key); return; } this._configOptions[key] = value; } /** * 初始化 * @protected */ _init(){ //获取最近一次登录信息 let lastLoginInfo = JSON.parse(wx.getStorageSync(this._configOptions.loginInfoStorage) || 'null'); this._loginInfo = lastLoginInfo || this._loginInfo; //无最近登录信息时，设置默认值 this._loginInfo.authType = this._loginInfo.authType || this._configOptions.defaultAuthType; //有指定前端登录态过期时间时，进行过期处理 if (this._loginInfo.expireTime&gt;0 &amp;&amp; Date.now()&gt;this._loginInfo.expireTime) this.clearLogin(); } /** * 登录 * @param {Object} [options] 登录选项 * @param {Function} [options.callback], 兼容起见支持回调，但更建议以Promise方式使用 * @param {string} [options.mode] 登录模式 * common - 通用模式，适合大部分页面场景 * silent - 静默模式，适合免打扰场景：只尝试静默登录，不触发授权弹窗；不管成功失败都不影响页面功能和后续接口调用 * force - 强制模式，刷新登录态 * forceSilent - 强制静默登录，对老用户，刷新登录态；对新用户，不触发授权 * forceAuth - 强制授权登录，强制展示授权界面 * @param {Function} [options.userAuthHandler] 自定义用户授权交互 * @param {String} [options.failAction] 失败处理方式：auto-自动处理 | none-调用方自行处理 | 其它-和onLoginFailed钩子函数约定的其它处理方式 * @param {Object} [options.thisIssuer] 触发登录的组件的this对象，供钩子函数使用 * * @return {Promise&lt;Object&gt;} res 登录结果，格式形如：{ code: 0, //状态码，0为成功，其它为失败 errMsg:'login api failed...', //详细错误日志，debug用 toastMsg: '您的账号存在安全风险，请联系客服进行处理' //（若有）用户话术，提示失败原因 } * code: * -100 用户交互失败 e.g.用户拒绝授权等 * -200 静默模式登录失败 * -300 授权登录失败 * -400 附加步骤返回失败结果 * -500 模块内部异常 */ async login(options={}){ //填充默认值 const defaultOpts = { callback: null, mode: 'common', userAuthHandler: this._configOptions.userAuthHandler, failAction: 'auto', thisIssuer: null, //触发登录的组件的this对象，供钩子函数使用 }; options = Object.assign({}, defaultOpts, options); //状态记录 let isNewlyLogin = !this.checkLogin(); //区分 未登录=&gt;已登录 和 已登录=&gt;刷新登录态 //登录 let loginRes = {}; try { loginRes = await this._login(options); } catch (e){ loginRes = {code: -500, errMsg:'internal error'}; //真机下不支持打印错误栈，导致e打印出来是个空对象；故先单独打印一次e.message console.error('[login failed] uncaught error:',e &amp;&amp; e.message, e); } //触发钩子 if (loginRes.code!==0 &amp;&amp; loginRes.code!==-200) { //钩子：登录失败 this._configOptions.onLoginFailed &amp;&amp; await this._configOptions.onLoginFailed.call(options.thisIssuer, loginRes, {failAction: options.failAction}) } if (loginRes.code===0 &amp;&amp; isNewlyLogin) { //钩子：刚刚登录 this._configOptions.onNewlyLogin &amp;&amp; await this._configOptions.onNewlyLogin.call(options.thisIssuer); } //返回结果 options.callback &amp;&amp; options.callback(loginRes); return loginRes; } /** * @private */ async _login(options){ //初始状态：未开始 let loginRes = {code: -1, errMsg: 'idle'}; //尝试复用本地登录态 let canUseLocal = !['force', 'forceSilent', 'forceAuth'].includes(options.mode); //是否可复用本地登录态 loginRes = canUseLocal &amp;&amp; this.checkLogin() ? {code: 0, errMsg: 'ok'} : loginRes; //本地登录状态 if (loginRes.code === 0) //当前已登录且模式无特殊要求，按成功返回 return {code: 0, errMsg: 'ok'}; //尝试静默登录 let canUseSilent = !['forceAuth'].includes(options.mode); //是否可尝试静默登录 loginRes = canUseSilent ? await this._silentLogin(options) : loginRes; if (loginRes.code === 0) //静默登录成功，结束 return {code: 0, errMsg: 'ok'}; //尝试授权登录 let canUseAuth = !['silent', 'forceSilent'].includes(options.mode); //是否可尝试授权登录 loginRes = canUseAuth ? await this._authLogin(options) : loginRes; if (loginRes.code === 0) //授权登录成功，结束 return {code: 0, errMsg: 'ok'}; //全部尝试失败，根据模式调整返回值 if (['silent', 'forceSilent'].includes(options.mode)) //静默模式错误码调整为统一值（这些模式不想让用户感知到登录失败） loginRes.code = -200; //返回最终失败结果 return loginRes; } /** * 静默登录 * 在用户无感知的情况下悄悄完成登录过程 * @param options * @return {Promise&lt;*&gt;} * @private */ @mergingStep async _silentLogin(options){ //判断使用的验证方式 let authType = this._loginInfo.authType; if (authType === 'none') return {code: -200, errMsg: 'login failed silently: disabled'}; //获取验证方式对应的鉴权器 let authEngine = this._configOptions.authEngineMap[authType]; if (!authEngine) { console.error('[login] _silentLogin, cannot find authEngine for authType:', authType); return {code: -500, errMsg: 'login failed silently: internal error'}; } //尝试静默登录 let silentRes = {}; try { silentRes = await authEngine.silentLogin({ loginOptions: options, configOptions: this._configOptions, }); } catch (e) { console.error('[login] caught error when try silentLogin of authType:', authType, 'err:', e); silentRes = {succeeded: false, errMsg: 'internal error'}; } //更新匿名信息（登录成功前使用的临时标识，成功后继续关联） silentRes.anonymousInfo &amp;&amp; this._saveAnonymousInfo(silentRes.anonymousInfo); //登录失败，返回 if (!silentRes.succeeded) return {code: -200, errMsg: 'login failed silently: normal'}; //登录成功，保存相关信息 return this._afterFetchInfoPack({ isLogin: true, userInfo: silentRes.userInfo, expireTime: silentRes.expireTime, authType, }); } @mergingStep async _authLogin(options){ //执行各鉴权器的beforeAuthLogin钩子 let beforeResMap = {}; for (let authType of Object.keys(this._configOptions.authEngineMap)) { let authEngine = this._configOptions.authEngineMap[authType]; beforeResMap[authType] = authEngine.beforeAuthLogin ? await authEngine.beforeAuthLogin({ loginOptions: options, configOptions: this._configOptions, }) : null; } //展示登录界面，等待用户交互 let userAuthRes = await this._handleUserAuth(options); //交互失败（e.g.用户取消登录） if (!userAuthRes.succeeded) { this._configOptions.onUserAuthFailed &amp;&amp; this._configOptions.onUserAuthFailed.call(options.thisIssuer,{}); return {code: -100, errMsg: 'user auth failed:' + userAuthRes.errMsg} } //交互成功 //触发钩子：onUserAuthSucceeded this._configOptions.onUserAuthSucceeded &amp;&amp; this._configOptions.onUserAuthSucceeded.call(options.thisIssuer); //根据用户提供的信息进行登录 let authType = userAuthRes.authType; let authEngine = this._configOptions.authEngineMap[authType]; if (!authEngine) { console.error(`[login] 当前指定的登录方式：${authType}，不存在对应的鉴权器`); return {code: -500, errMsg: 'internal error'}; } let authRes = await authEngine.authLogin({ loginOptions: options, configOptions: this._configOptions, authData: userAuthRes.authData, beforeRes: beforeResMap[authType], }); //更新匿名信息（登录成功前使用的临时标识，成功后继续关联） authRes.anonymousInfo &amp;&amp; this._saveAnonymousInfo(authRes.anonymousInfo); //登录失败，返回 if (!authRes.succeeded) return {code: -300, errMsg: `auth login failed: ${authRes.errMsg}`, toastMsg: authRes.toastMsg}; //登录成功，保存相关信息 return this._afterFetchInfoPack({ isLogin: true, userInfo: authRes.userInfo, expireTime: authRes.expireTime, authType, }); } /** * * @param options * @return {Promise&lt;{succeeded: boolean, errMsg: string, authType: string, authData: {}}&gt;} * 交互结果，格式形如： { succeeded: true, //是否成功 errMsg: '', //错误信息，调试用 authType: '', //用户选择的验证方式 authData: {}, //交互数据，格式由该验证方式对应的鉴权器指定 } * @protected */ async _handleUserAuth(options){ return await options.userAuthHandler.call(options.thisIssuer); } /** * 登录信息获取完毕后续步骤集合 * @private */ async _afterFetchInfoPack(loginInfo){ this._saveInfo(loginInfo); let addOnRes = await this._handleAddOn(); if (!addOnRes.succeeded) { this.clearLogin(); return {code: -400, errMsg: addOnRes.errMsg||'add on failed', toastMsg: addOnRes.toastMsg}; } return {code: 0, errMsg: 'ok'}; } _saveInfo(loginInfo){ Object.assign(this._loginInfo, loginInfo); wx.setStorage({ key: this._configOptions.loginInfoStorage, data: JSON.stringify(this._loginInfo) }); } _saveAnonymousInfo(anonymousInfo){ Object.assign(this._loginInfo.anonymousInfo, anonymousInfo); wx.setStorage({ key: this._configOptions.loginInfoStorage, data: JSON.stringify(this._loginInfo) }); } /** * 支持使用方配置自定义附加步骤，会在正常登录流程执行成功时调用，并根据其处理结果生成最终登录结果 * @return {Promise&lt;*&gt;} */ async _handleAddOn(){ if (!this._configOptions.loginStepAddOn) return {succeeded: true}; let stepRes = await this._configOptions.loginStepAddOn(); if (typeof stepRes !== \"object\"){ console.error('[login] loginStepAddOn shall return an object, something like \"{succeeded: true, errMsg:\\'debug detail\\', toastMsg: \\'alert detail\\'}\", yet got return value:', stepRes); stepRes = {succeeded: false}; } return stepRes; } /** *退出登录 * @param {boolean} needClearAuth 是否需要清除鉴权信息：false-仅清除登录态，下次还可以静默登录 | true-同时清除鉴权信息，下次必须授权登录 * @return {Object} res 退出登录结果，格式形如：{code:0, errMsg:'ok'} */ logout({needClearAuth = false}={}){ this.clearLogin({needClearAuth}); return {code: 0}; } /** * 重新登录 * @return {Object} 登录结果，格式同login */ async reLogin(...args){ await this.logout(); return await this.login(...args); } /** * 清除前端登录态 * @param {boolean} needClearAuth 是否需要清除鉴权信息：false-仅清除登录态，下次还可以静默登录 | true-同时清除鉴权信息，下次必须授权登录 */ clearLogin({needClearAuth=false}={}){ this._loginInfo.isLogin = false; this._loginInfo.userInfo = {}; this._loginInfo.expireTime = -1; this._loginInfo.authType = needClearAuth ? 'none' : this._loginInfo.authType; wx.setStorage({ key: this._configOptions.loginInfoStorage, data: JSON.stringify(this._loginInfo) }); } /** * 检查是否登录 * @return {boolean} 是否登录 */ checkLogin(){ return this._loginInfo.isLogin; } /** * 将方法封装为通用函数，使之可以在任意this对象上执行 * @param {String} methodName 方法名 * @return {Function} 封装后的函数 */ makeAssignableMethod(methodName){ return makeAssignableMethod({ instance: this, method: methodName, rcvThis: { argIdx: 0, argProp: 'thisIssuer' } }); } /** * 获取用户信息 * @return {Object} 用户信息 */ get userInfo(){ return deepClone(this._loginInfo.userInfo); } } /** * 类修饰器，确保调用API时已完成项目信息配置 * @param target */ function requireConfig(target) { let descriptors = Object.getOwnPropertyDescriptors(target.prototype); for (let prop of Object.getOwnPropertyNames(descriptors)){ let descriptor = descriptors[prop]; if (typeof descriptor.value !== \"function\") //非函数，不予处理 continue; if (['constructor', 'config'].includes(prop) || prop[0]==='_') //无需配置的函数、私有函数，不予处理 continue; descriptor.value = (function (oriFunc, funcName) { //对外接口，增加配置检查步骤 return function (...args) { if (!this._stateInfo.isConfigReady){ //若未进行项目信息配置，则报错 console.error('[Login] 请先进行模块配置，后调用模块相关功能', '试图调用：', funcName); return; } return oriFunc.apply(this, args); //否则正常执行原函数 } }(descriptor.value, prop)); Object.defineProperty(target.prototype, prop, descriptor); } } export default BaseLogin; × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"navigate_Navigator.js.html":{"id":"navigate_Navigator.js.html","title":"Source: navigate/Navigator.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: navigate/Navigator.js import History from './History'; import {makeMutex, noConcurrent} from '../decorator/noConcurrent'; import {ctxDependConsole as console} from '../debugKit'; import {delay, appendUrlParam, toAbsolutePath} from '../operationKit'; import {customWxPromisify} from '../wxPromise'; import {supportWXCallback} from '../decorator/compatible'; const NAV_BUSY_REMAIN = 300; //实践发现，navigateTo成功回调之后页面也并未完全完成跳转，故将跳转状态短暂延长，单位：ms let wxPromise=null, wxResolve=null; //部分API支持用户自定义覆盖，因而等到配置环节再予以实例化 let globalStore = { env: { os: 'ios' } }; wx.getSystemInfo({ success(sysInfo){ globalStore.env.os = sysInfo.system.toLowerCase().includes('ios') ? 'ios' : 'android'; } }); /** * 导航器 * 由于小程序只支持最多5级页面（后放宽至10级），但需求上希望维护更长的历史栈，故自行维护完整历史栈并改写默认导航操作 * 使用：详见 docs/无限层级路由方案.md */ export default class Navigator { static _config = { enableCurtain: true, //是否开启空白中转策略 curtainPage: '/pages/curtain/curtain', //空白中转页，避免自定义返回行为时出现原生上一层级内容一闪而过的现象 enableTaintedRestore: true, //是否开启实例覆盖自动恢复策略 /** * 自定义页面数据恢复函数，用于 * 1. wepy实例覆盖问题，存在两级同路由页面时，前者数据会被后者覆盖，返回时需予以恢复 * 2. 层级过深时，新开页面会替换前一页面，导致前一页面数据丢失，返回时需予以恢复 * * @param {string} route.url 页面url，绝对路径 * @param {object} route.wxPage 页面卸载前的原生页面实例拷贝 * @param {string} context 数据丢失场景： tainted - 实例覆盖问题导致的数据丢失 | unloaded - 层级问题导致的数据丢失 * @return {boolean} res.succeeded 数据恢复是否成功，若成功，则恢复结束；若失败，则模块将继而尝试使用默认恢复策略 * * e.g. function({route, context}){return {succeeded: true}} */ pageRestoreHandler: null, MAX_LEVEL: 10, //小程序支持打开的页面层数 oriNavOverrides: {}, //自定义覆盖部分/全部底层跳转api（wx.navigateTo、wx.redirectTo等），接口及参数格式同wx }; static _history = new History({routes: [{url:''}]}); //完整历史栈 static _activeUnload = false; //是否为主动触发的页面卸载： true-代码主动调用导致； false-用户点击了物理返回键/左上角返回按钮导致 /** * 安装 * @param {Object} options 自定义配置，可配置项参见 _config 相关字段及注释 */ static config(options={}){ //自定义配置 Object.assign(Navigator._config, options); Navigator._history.config({correctLevel: Navigator._config.MAX_LEVEL-2}); wxPromise = customWxPromisify({overrides: Navigator._config.oriNavOverrides, dealFail: false}); wxResolve = customWxPromisify({overrides: Navigator._config.oriNavOverrides, dealFail: true}); } /** * 打开新页面 * @param {Object} route 页面配置，格式同wx.navigateTo */ @supportWXCallback //兼容success、fail、complete回调 @makeMutex({ //避免跳转相关函数并发执行 namespace:globalStore, mutexId:'navigate', discardRes: { succeeded: false, errMsg: 'discarded by noConcurrent strategy' } }) static async navigateTo(route){ console.log('[Navigator] navigateTo:', route); let curPages = getCurrentPages(); let curPage = curPages[curPages.length-1]; Navigator._history.open({url: toAbsolutePath(route.url, curPage.route||curPage.__route__)}); if (Navigator._config.enableCurtain &amp;&amp; curPages.length == Navigator._config.MAX_LEVEL-1) { //空白中转策略：倒数第二层开最后一层时，先把倒二层换成空白页，再打开最后一层 console.log('[Navigator] replace with curtain', 'time:', Date.now(), 'getCurrentPages:', getCurrentPages()); Navigator._history.savePage(Navigator._history.length-2, curPages[curPages.length-1]); //保存页面数据 await Navigator._secretReplace({url: Navigator._config.curtainPage}); console.log('[Navigator] open from curtain', 'time:', Date.now(), 'getCurrentPages:', getCurrentPages()); await Navigator._secretOpen(route); } else if (curPages.length &lt; Navigator._config.MAX_LEVEL) { //层级未满，直接打开 await Navigator._secretOpen(route); } else { //层数已占满时，替换最后一层 Navigator._history.savePage(Navigator._history.length-2, curPages[curPages.length-1]); //保存页面数据 await Navigator._secretReplace(route); } return {succeeded: true, errMsg: 'ok'}; } /** * 替换当前页面 * @param {Object} route 页面配置，格式同wx.redirectTo */ @supportWXCallback //兼容success、fail、complete回调 static async redirectTo(route){ console.log('[Navigator] redirectTo:', route); let curPages = getCurrentPages(); let curPage = curPages[curPages.length-1]; Navigator._history.replace({url: toAbsolutePath(route.url, curPage.route||curPage.__route__)}); await Navigator._secretReplace(route) return {succeeded: true, errMsg: 'ok'}; } /** * 返回 * @param {Object} opts 返回配置，格式同wx.navigateBack */ @supportWXCallback //兼容success、fail、complete回调 static async navigateBack(opts={delta:1}){ console.log('[Navigator] navigateBack:', opts); await Navigator._doBack(opts, {sysBack: false}); return {succeeded: true, errMsg: 'ok'}; } @supportWXCallback //兼容success、fail、complete回调 @makeMutex({ //避免跳转相关函数并发执行 namespace:globalStore, mutexId:'navigate', discardRes: { succeeded: false, errMsg: 'discarded by noConcurrent strategy' } }) static async reLaunch(route){ console.log('[Navigator] reLaunch:', route); Navigator._activeUnload = true; await wxPromise.reLaunch(route); await delay(NAV_BUSY_REMAIN); return {succeeded: true, errMsg: 'ok'}; } @supportWXCallback //兼容success、fail、complete回调 @makeMutex({ //避免跳转相关函数并发执行 namespace:globalStore, mutexId:'navigate', discardRes: { succeeded: false, errMsg: 'discarded by noConcurrent strategy' } }) static async switchTab(route){ console.log('[Navigator] switchTab:', route); Navigator._activeUnload = true; await wxPromise.switchTab(route); await delay(NAV_BUSY_REMAIN); return {succeeded: true, errMsg: 'ok'}; } /** * 主动触发的页面卸载过程结束标记 * 目前似乎无法监听接口主动触发的页面卸载过程什么时候结束： * 1. reLaunch、redirectTo等接口会立刻进行success回调，不会等待页面卸载、跳转完成再回调 * 2. redirectTo到一个分包页面时，须等待分包加载完成，然后才发生页面卸载、跳转，过程耗时不可预估 * 因而采取如下策略判断结束时机：从第一个页面卸载开始，若干延时后，认为该次操作触发的全部页面卸载过程结束 * @return {Promise&lt;void&gt;} * @private */ @noConcurrent static async _finishActiveUnload(){ await delay(300); //reLaunch、switchTab等可能一次性触发多个onUnload，因而须等所有onUnload均触发完毕后才能将_activeUnload置回false Navigator._activeUnload = false; } /** * 监听页面卸载过程；本质是想监听用户的返回操作（点击物理返回键/左上角返回按钮），但似乎并没有相应接口，暂借助页面onUnload过程进行判断 */ static onPageUnload(){ if (Navigator._activeUnload) {//调用接口主动进行页面卸载，此处不再重复处理 Navigator._finishActiveUnload(); return; } //用户点击了物理返回键/左上角返回按钮 console.log('[Navigator] sysBack'); Navigator._doBack({delta:1}, {sysBack: true}); } /** * 完整历史记录 * @return {Array} */ static get history(){ return Navigator._history.routes; } /** * 返回 * @param {Object} opts 返回配置，格式同wx.navigateBack * @param {boolean} sysBack， 是否为系统返回： true-点击了物理返回键/左上角返回按钮，触发了系统返回行为；false-接口调用，返回逻辑完全由代码控制 * @private */ static async _doBack(opts, {sysBack}){ let targetRoute = Navigator._history.back(opts); let curLength = getCurrentPages().length - (sysBack ? 1 : 0); //当前实际层级（系统返回无法取消，实际层级需要减1） console.log('[Navigator] doBack, hisLength:', Navigator._history.length, 'curLen:', curLength, 'targetRoute:', targetRoute); let targetCurtain = Navigator._config.enableCurtain &amp;&amp; Navigator._history.length==Navigator._config.MAX_LEVEL-1; //目标页面是否为中转空白页（空白中转策略） let targetTainted = Navigator._config.enableTaintedRestore &amp;&amp; targetRoute.tainted; //目标页面数据是否已被覆盖（wepy单页面实例问题） if (Navigator._history.length &lt; curLength) { //返回后逻辑层级&lt;当前实际层级，则直接返回到目标层级（如 MAX+2 层调用 navigateBack({delta: 3}) ) await Navigator._secretBack({ delta: curLength-Navigator._history.length }); if (targetCurtain) {//当前页为中转空白页（空白中转策略），则替换为目标页面 await Navigator._secretReplace(targetRoute, {extraParams: {_forcedRefresh: true}}); await Navigator._doLostRestore(targetRoute); } else if (targetTainted) { //若目标页面实例已被覆盖（wepy单页面实例问题），则进行数据恢复 await Navigator._doTaintedRestore(targetRoute); } } else if (Navigator._history.length === curLength) { //返回后逻辑层级===当前实际层级 if (!sysBack || targetCurtain) {//非系统返回 （如 MAX+1 层调用navigateBack()）或 当前页为中转空白页，则重定向至目标页面 await Navigator._secretReplace(targetRoute, {extraParams: {_forcedRefresh: true}}); await Navigator._doLostRestore(targetRoute); } else if (targetTainted){ //目标页面已被覆盖 await Navigator._doTaintedRestore(targetRoute); } //否则，系统返回即符合预期，无需额外处理 } else { //返回后逻辑层级 &gt; 当前实际层级，则在最后一层载入目标页面 （如 MAX+5 层返回 MAX+4 层） await (sysBack ? Navigator._secretOpen(targetRoute, {extraParams: {_forcedRefresh: true}}) : Navigator._secretReplace(targetRoute, {extraParams: {_forcedRefresh: true}})); await Navigator._doLostRestore(targetRoute); } } /** * 不考虑历史记录问题，实际进行打开页面操作 * @param route 页面参数 * @param extraParams 向页面url额外拼接参数 * @param retryAfter 若因webview层级错乱原因导致打开失败，则在指定毫秒后重试 * @param retryTimeout 重试间隔大于指定毫秒时，判定打开失败，不再重试 * @private */ static async _secretOpen(route, {retryAfter=NAV_BUSY_REMAIN, retryTimeout=2000, extraParams=null}={}){ console.log('[Navigator] _secretOpen', route); let openRes = await wxResolve.navigateTo(Object.assign({}, route, {success: null, fail: null, url: appendUrlParam(route.url, extraParams)})); //打开成功 if (openRes.succeeded) { typeof route.success === \"function\" &amp;&amp; route.success(openRes); await delay(NAV_BUSY_REMAIN); return; } //层级问题导致的打开失败 if (openRes.errMsg.includes('limit exceed')) { //超出层级限制无法打开，改为替换当前页 if (getCurrentPages().length &gt;= Navigator._config.MAX_LEVEL) { return Navigator._secretReplace(route, {extraParams}); } //异常报错，如：实践发现，重定向倒二层、打开最后一层 两个操作连续进行时，虽然层级实际并未超出限制，但在某些机型某些页面上仍会报层级问题 if (retryAfter &lt; retryTimeout) { //此时，重试几次，每次间隔时间递增 console.warn('[Navigator] false limit alarm, retry after:', retryAfter, 'ms', route); await delay(retryAfter); return Navigator._secretOpen(route, {retryAfter: retryAfter*2, retryTimeout, extraParams}); } else { //等待足够长的时间间隔后才重试依然失败，则打开失败 console.error('[Navigator error] _secretOpen failed, res:', openRes, 'getCurrentPages:',getCurrentPages(), 'longest retry interval:', retryAfter/2); typeof route.fail === \"function\" &amp;&amp; route.fail(openRes); throw openRes; } } //其它原因导致的打开失败 typeof route.fail === \"function\" &amp;&amp; route.fail(openRes); throw openRes; } /** * 不考虑历史记录问题，实际进行页面替换操作 * @param route * @param extraParams 向页面url额外拼接参数 * @private */ static async _secretReplace(route, {extraParams=null}={}){ console.log('[Navigator] _secretReplace', route); Navigator._activeUnload = true; await wxPromise.redirectTo(Object.assign({}, route, {url: appendUrlParam(route.url, extraParams)})); await delay(NAV_BUSY_REMAIN); } /** * 不考虑历史记录问题，实际进行页面返回操作 * @param opts * @private */ static async _secretBack(opts={delta:1}){ console.log('[Navigator] _secretBack', opts); Navigator._activeUnload = true; await wxPromise.navigateBack(opts); await delay(globalStore.env.os=='ios' ? NAV_BUSY_REMAIN*3 : NAV_BUSY_REMAIN); } /** * 数据恢复：wepy实例覆盖问题，存在两级同路由页面时，前者数据会被后者覆盖，返回时予以恢复 * 此时滚动位置等界面状态均正常，恢复数据即可 * @param route * @return {Promise&lt;void&gt;} * @private */ static async _doTaintedRestore(route){ //若有自定义页面数据恢复机制，则尝试以自定义方式恢复数据 let res = Navigator._config.pageRestoreHandler &amp;&amp; Navigator._config.pageRestoreHandler({ route, context: 'tainted' }); if (res instanceof Promise) res = await res; if (res &amp;&amp; res.succeeded) return; //若自定义恢复失败，则以刷新页面的方式恢复数据（不会保留表单数据和交互状态，但至少保证页面数据不错乱） await Navigator._secretReplace(route, {extraParams: {_forcedRefresh: true}}); } /** * 数据恢复：层级过深，新开页面时会替换前一页面，导致前一页面数据丢失，返回时予以恢复 * 此时页面处于刷新结束状态，表单数据和交互状态均需自行恢复 * @param route * @return {Promise&lt;void&gt;} * @private */ static async _doLostRestore(route){ //若有自定义页面数据恢复机制，则尝试以自定义方式恢复数据 Navigator._config.pageRestoreHandler &amp;&amp; Navigator._config.pageRestoreHandler({ route, context: 'unloaded' }); //否则，页面保持刷新状态，暂不提供默认恢复机制 } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"Cookie.js.html":{"id":"Cookie.js.html","title":"Source: Cookie.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: Cookie.js /** * cookie管理器 * 利用前端存储，模拟实现web中的cookie逻辑 * 很多时候，后端现有接口是先前对接M页/APP开发的，可能会使用cookie进行参数获取/传递；但小程序不支持cookie，导致后端接口复用/多端兼容成本增高。 * 利用本cookie管理器，结合./request/plugin/CookiePlugin中的cookie插件，可以在接口调用前后，自动植入cookie逻辑，便于小程序端复用cookie相关逻辑。 * * 注：目前仅支持基础的取值赋值操作，domain、path、expires等各种配置选项暂未支持，会予以忽略 */ export default class Cookie { _cookieStorage = ''; //cookie相关信息存储到storage时使用的key _cookieStr = ''; //当前cookie列表，格式：'key1=value1;key2=value2' /** * 构造函数 * @param {string} cookieStorageName cookie相关信息存储到storage时使用的key */ constructor({cookieStorageName='__cookie'}={}){ this._cookieStorage = cookieStorageName; } /** * 读取指定cookie * key未传时，返回全部cookie * @param {string} [key] 要读取的key * @param {object} [options] 配置选项（暂未支持） * @return {string | object} cookie中key对应的value | 未传key时，返回全部key-value组成的对象 */ get(key, options){ let cookieStr = this.getCookie(); let cookieObj = Cookie.cookieStrToObj(cookieStr); return key === undefined ? cookieObj : (cookieObj[key] || ''); } /** * 写入指定cookie * @param {string} key 要写入的key * @param {string} value 要写入的value * @param {object} [options] 配置选项（暂未支持） */ set(key, value, options){ this.setCookie(`${key}=${value};`); } /** * 获取当前可访问的cookie字符串 * @return {string} cookie字符串，形如：'key1=value1;key2=value2'（类似web中读取document.cookie） */ getCookie(){ // 优先尝试从内存中读取，尽量减少访问storage的开销 if(this._cookieStr) return this._cookieStr; this._cookieStr = wx.getStorageSync(this._cookieStorage); return this._cookieStr; } /** * 写入cookie * @param {string} setStr 写入指令，格式形如：'key1=value1; path=/;'（类似web中document.cookie赋值） */ setCookie(setStr){ //参数处理 setStr = setStr.trim(); //字段配置 let setKey = ''; //要赋值的key let setValue = ''; //要赋值的value let configOptions = {}; //配置项：domain、path、expires等 //字段解析 let fieldStrArr = setStr.split(/\\s*;\\s*/); for (let [fieldIdx, fieldStr] of fieldStrArr.entries()) { let sepIdx = fieldStr.indexOf('='); let name = fieldStr.substring(0, sepIdx); let value = fieldStr.substring(sepIdx+1); if (fieldIdx === 0) { //第一个选项，认为是要赋值的key setKey = name; setValue = value; } else { //其它选项，认为是配置项 configOptions[name.toLowerCase()] = value; } } //字段检查 if (!setKey) { console.error('[setCookie] bad param, no key found:', setStr); return; } //更新cookie（配置项暂予忽略） this._cookieStr = Cookie.mergeCookieStr(this._cookieStr, `${setKey}=${setValue};`); wx.setStorage({ key: this._cookieStorage, data: this._cookieStr, }); } /** * 将'key1=value1;key2=value2'形式的cookie字符串转为{key1: value1, key2: value2}的对象形式 * @param {string} cookieStr * @return {Object} cookieObj */ static cookieStrToObj(cookieStr){ let fieldStrArr = cookieStr.split(/\\s*;\\s*/).filter(fieldStr=&gt;!!fieldStr); let cookieObj = {}; for (let fieldStr of fieldStrArr) { // 注意不要直接用匹配split('='), ppu等含=的不规则cookie会出错 let index = fieldStr.indexOf('='); let key = fieldStr.substring(0, index); let value = fieldStr.substring(index+1); cookieObj[key] = value; } return cookieObj; } /** * 将{key1: value1, key2: value2}的对象形式键值对转为'key1=value1;key2=value2'形式的cookie字符串 * @param {Object} cookieObj * @return {string} cookieStr */ static cookieObjToStr(cookieObj){ let cookieStr = ''; for (let key in cookieObj) cookieStr += `${key}=${cookieObj[key]};`; return cookieStr; } /** * 将'key1=value1;key2=value2'形式的cookie字符串合并，key相同时后面的覆盖前面的 * @param {string} cookieStrs */ static mergeCookieStr(...cookieStrs) { let cookieObjs = cookieStrs.filter(cookieStr=&gt;!!cookieStr).map(Cookie.cookieStrToObj); let cookieObj = Object.assign( {}, ...cookieObjs, ); return Cookie.cookieObjToStr(cookieObj); } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"debugKit.js.html":{"id":"debugKit.js.html","title":"Source: debugKit.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: debugKit.js const debug = false; //调试开关， todo:根据运行模式/其它条件自动判断是否开启调试 /** * 上下文相关的控制台：开启调试模式时，功能同系统console；关闭调试模式时，忽略所有console调用。调试模式开关由本模块自动获取/统一指定，对调用方透明。 * 使用示例： * import {ctxDependConsole as console} from '../../lib/debugKit' * console.log('ha ha ha'); //开启调试模式时，打印'ha ha ha'；关闭调试模式时，自动无视此行代码 */ export const ctxDependConsole = (function () { let ctxDependConsole = {}; for (let p in console) { if (typeof console[p] !== \"function\") { ctxDependConsole[p] = console[p]; continue; } ctxDependConsole[p] = debug ? console[p] : function () {}; } return ctxDependConsole; })(); × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"wxPromise.js.html":{"id":"wxPromise.js.html","title":"Source: wxPromise.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: wxPromise.js /** * 小程序API的Promise封装，用法与wx一致，只是返回结果为Promise形式 * 示例： async func(){ let imgInfo = await wxPromise.getImageInfo({src: 'https://xxx'}); //调用wx.getImageInfo，并在success回调中resolve console.log(imgInfo.width); //打印图片信息 } */ export const wxPromise = promisify(wx, {dealFail: false}); /** *同wxPromise，差别在于wxPromise在成功时resolve，失败时reject，而wxResolve不管成功失败都会resolve，便于手动处理异常情形 * 示例： async func(){ let copyRes = await wxResolve.setClipboardData({ data: 'hello'}); //复制到剪贴板 this.$toast({ //成功失败均予以提示 title: copyRes.succeeded ? '复制成功' : '复制失败', type: copyRes.succeeded ? 'success' : 'fail', }); } */ export const wxResolve = promisify(wx, {dealFail: true}); /** * 自定义Promise化方式 * @param {Object} overrides 自定义覆盖wx的部分接口 * @param {boolean} dealFail true - 失败时也resolve，并标记res.succeeded=false； false - 失败时直接reject * @return {Object} Promise化的wx */ export function customWxPromisify({overrides={}, dealFail=false}={}) { let wxRefine = Object.assign({}, wx, overrides); return promisify(wxRefine, {dealFail}); } function promisify(callbackSdk, {dealFail=false}) { let promiseSdk = {}; for (let key in callbackSdk) { if (typeof callbackSdk[key] !== \"function\" || /[^a]sync$/i.test(key)) { promiseSdk[key] = callbackSdk[key]; continue; } promiseSdk[key] = function (options={}) { return new Promise((resolve, reject)=&gt;{ return callbackSdk[key](Object.assign({}, options, { success(res){ Object.assign(res, {succeeded: true}); options.success &amp;&amp; options.success(res); resolve(res); }, fail(res){ Object.assign(res, {succeeded: false}); options.fail &amp;&amp; options.fail(res); dealFail ? resolve(res) : reject(res); }, })); }); } } return promiseSdk; } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"wepyKit.js.html":{"id":"wepyKit.js.html","title":"Source: wepyKit.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: wepyKit.js import wepy from 'wepy'; /** * 注册全局this属性 * @param {Object|string} lib|name * @param {Object|*} propMap|value e.g. registerToThis('$navigateTo', wx.navigateTo); registerToThis('$redirectTo', wx.redirectTo); registerToThis(wx, {'$navigateTo': 'navigateTo', '$redirectTo': 'redirectTo'}); 则所有页面&amp;组件可以以 this.$navigateTo 的形式调用 wx.navigateTo */ export function registerToThis(lib, propMap) { if (typeof lib === \"string\") { let [name, value] = [lib, propMap]; lib = { [name]: value }; propMap = { [name]: name }; } if (!((typeof lib===\"object\"||typeof lib===\"function\") &amp;&amp; typeof propMap===\"object\")) { console.error('[registerToThis failed] bad params:', arguments); return; } for (let prop in propMap) wepy.component.prototype[prop] = propMap[prop]==='*this' ? lib : lib[propMap[prop]]; } /** * 注册全局页面钩子 * @param {string} hook 页面生命周期钩子名称 * @param {Function} handler 处理函数 * * 注：页面中若有自定义同名钩子，则全局钩子会被覆盖，需要手动触发，如： 页面有自定义onUnload时需在onUnload中调用 super.onUnload &amp;&amp; super.onUnload(); */ export function registerPageHook(hook, handler) { if (typeof handler !== \"function\") { console.error('[registerPageHook] bad params:', hook, handler); return; } let oriHook = wepy.page.prototype[hook]; wepy.page.prototype[hook] = function () { oriHook &amp;&amp; oriHook.apply(this, arguments); handler.apply(this, arguments); }; } /** * 页面数据恢复函数，用于 * 1. wepy实例覆盖问题，存在两级同路由页面时，前者数据会被后者覆盖，返回时需予以恢复，详见bug：[两级页面为同一路由时，后者数据覆盖前者](https://github.com/Tencent/wepy/issues/322) * 2. 无限层级路由策略中，层级过深时，新开页面会替换前一页面，导致前一页面数据丢失，返回时需予以恢复 * * @param {object} route 页面路由对象 * @param {string} route.url 页面url，绝对路径 * @param {object} route.wxPage 页面卸载前的原生页面实例拷贝 * @param {string} context 数据丢失场景： tainted - 实例覆盖问题导致的数据丢失 | unloaded - 层级问题导致的数据丢失 * @return {{succeeded: boolean}} 数据恢复是否成功，若成功，则恢复结束；若失败，则模块将继而尝试使用默认恢复策略 */ export function pageRestoreHandler({route, context}) { let path = route.url.split('?')[0]; let wepyPage = wepy.$instance.$pages[path]; dataRestoreWx2Wepy(wepyPage, route.wxPage.data); return {succeeded: true}; } /** * 从原生页面数据中恢复wepy页面/组件实例数据 * @param {object} compThis wepy页面/组件根实例 * @param {object} data 原生页面数据 * @param {string} compPrefix 根实例数据在原生页面数据中的前缀，如： ''(页面实例）、'$PageFrame$'(页面下的PageFrame组件）、'$PageFrame$BackHome$'（PageFrame组件下的BackHome组件） * @return void 会将根实例及其所有后代组件实例 数据恢复为与原生页面数据保持一致的状态 */ function dataRestoreWx2Wepy(compThis, data, compPrefix='') { //恢复组件自身的数据 let selfData = {}; for (let prop in data) { if (prop.startsWith(compPrefix) &amp;&amp; !prop.substring(compPrefix.length).includes('$')) selfData[prop.substring(compPrefix.length)] = data[prop]; } Object.assign(compThis, selfData); compThis.$apply(); //恢复后代组件的数据 for (let childName in compThis.$com) { dataRestoreWx2Wepy(compThis.$com[childName], data, (compPrefix || '$')+childName+'$'); } } /** * 支持prefetch等附加功能的路由模块，格式与wx保持一致 */ export const NavRefine = { navigateTo(options){ getCurWepyPage().$navigate(options); }, redirectTo(options){ getCurWepyPage().$redirect(options); } } export function getCurWepyPage() { let curPages = getCurrentPages(); let curPage = curPages[curPages.length-1]; let curPath = '/' + (curPage.route || curPage.__route__); return wepy.$instance.$pages[curPath]; } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"decorator_errSafe.js.html":{"id":"decorator_errSafe.js.html","title":"Source: decorator/errSafe.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: decorator/errSafe.js /** * 捕获async函数中的异常，并进行错误提示 * 函数正常结束时应 return 'ok'，return其它文案时将toast指定文案，无返回值或产生异常时将toast默认文案 * @param {string} defaultMsg 默认文案 * @param {number} [duration] 可选，toast持续时长 */ export function withErrToast({defaultMsg, duration=2000}) { return function (target, funcName, descriptor) { let oriFunc = descriptor.value; descriptor.value = async function () { let errMsg = ''; let res = ''; try { res = await oriFunc.apply(this, arguments); if (res != 'ok') errMsg = typeof res === 'string' &amp;&amp; !/^\\s*$/.test(res) ? res : defaultMsg; } catch (e) { errMsg = defaultMsg; console.error('caught err with func:',funcName, e.message, e);//真机下不支持打印错误栈，导致e打印出来是个空对象；故先单独打印一次e.message } if (errMsg) { this.$toast({ title: errMsg, type: 'fail', duration: duration, }); } return res; } } } /** * 捕获函数异常，避免阻断主流程 */ export function errSafe(target, funcName, descriptor) { let oriFunc = descriptor.value; descriptor.value = function () { try { let res = oriFunc.apply(this, arguments); if (res instanceof Promise) { res.catch((e)=&gt;{ console.error('[errSafe decorator] caught err with func:',funcName, e.message, e); }); } return res; } catch (e) { console.error('[errSafe decorator] caught err with func:',funcName, e.message, e); //真机下不支持打印错误栈，导致e打印出来是个空对象；故先单独打印一次e.message } } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"RewardedVideoPlayer.js.html":{"id":"RewardedVideoPlayer.js.html","title":"Source: RewardedVideoPlayer.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: RewardedVideoPlayer.js import {singleAisle, errSafe} from './decorators'; import {ctxDependConsole as debugConsole} from './debugKit'; /** * 激励视频播放器，封装激励视频加载、播放时序 * 使用： * 1. 初始化：this.rewardedVideoPlayer = new RewardedVideoPlayer({adUnitId: '广告位id'}) * 2. 监听页面onShow: onShow(){ this.rewardedVideoPlayer.handlePageChange() }; * 3. 播放视频： let playRes = await this.rewardedVideoPlayer.play(); if (playRes.code !== 0) { //播放异常（微信版本过低/视频加载失败/其它异常情况） wx.showToast({ title: playRes.errMsg }) } else if (!playRes.isEnded) { //用户提前关闭视频 ; } else { //正常完整观看 ; } * 更多用法详见各函数注释 */ export default class RewardedVideoPlayer { _adUnitId = ''; //广告位id _rewardedVideo = null; //原生视频实例 _loadStateValue = 'notStart'; //视频加载状态：notStart-未开始 | notSupport-版本过低不支持 | loading-加载中 | failed-加载失败 | loaded-加载成功 _playStateValue = 'idle'; //视频播放状态：idle-空闲中 | playing-播放中 | aborted-中途退出 | ended-播放完毕 _loadStateChangeListeners = []; //加载状态监听列表 /** * 构造函数 * @param {string} adUnitId 广告位id */ constructor({adUnitId}){ this._adUnitId = adUnitId; this._init(); } _init(){ if (!wx.createRewardedVideoAd) { this._rewardedVideo = null; this._loadState = 'notSupport'; this._playState = 'idle'; return; } this._rewardedVideo = wx.createRewardedVideoAd({ adUnitId: this._adUnitId }); this._rewardedVideo.onError((e)=&gt;{ console.error('[rewardedVideoPlayer] error:', e); this._loadState==='loading' &amp;&amp; (this._loadState = 'failed'); this._playState==='playing' &amp;&amp; (this._playState = 'failed'); }); this._loadState = 'notStart'; this._playState = 'idle'; } /** * 切换页面时原生视频实例失效，故每次onShow需重新初始化 * @param {boolean} preload 是否需要预加载视频：true-开始预加载 | false-不进行预加载（后续可手动调用load()决定加载时机） */ handlePageChange({preload=true}={}){ debugConsole.log('[rewardedVideoPlayer] enter handlePageChange'); if (this._playState === 'playing') //点击广告链接跳转其它小程序返回造成的onShow return; debugConsole.log('[rewardedVideoPlayer] re init'); this._init(); preload &amp;&amp; this.load(); } /** * 开始加载视频 * @param {boolean} reset 是否需要重置：true-强制重新加载 | false-可复用已有视频 */ @singleAisle @errSafe async load({reset=false}={}){ debugConsole.log('[rewardedVideoPlayer] enter load'); if (!this._rewardedVideo) return {succeeded: false}; if (this._loadState==='loaded' &amp;&amp; !reset) return {succeeded: true}; this._loadState = 'loading'; debugConsole.log('[rewardedVideoPlayer] begin load'); let loadRes = await new Promise((resolve,reject)=&gt;{ this._rewardedVideo.load().then(()=&gt;{ resolve({succeeded: true}); }).catch((e)=&gt;{ console.error('[rewardedVideoPlayer] load failed, exception:', e); resolve({succeeded: false}); }); }); debugConsole.log('[rewardedVideoPlayer] finish load, res:', loadRes); this._loadState = loadRes.succeeded ? 'loaded' : 'failed'; return {succeeded: loadRes.succeeded}; } /** * 开始播放视频 * @return {Promise&lt;Object&gt;} 播放结果 { code: 0, //是否正常：0-正常播放，其它-播放异常（微信版本过低/视频加载失败/其它异常情况） errMsg: '', //异常提示信息 isEnded: true, //（正常时）是否观看完整 * } */ @errSafe async play(){ debugConsole.log('[rewardedVideoPlayer] enter play'); //低版本兼容 if (!this._rewardedVideo) return {code: -1, errMsg: '您的微信版本较低，不支持此功能', isEnded: false}; //加载视频 if (this._loadState !== 'loaded'){ wx.showLoading({ title: '视频加载中' }); await this.load(); wx.hideLoading(); if (this._loadState !== 'loaded') return {code: -2, errMsg: '没有更多视频了', isEnded: false}; } //播放视频 debugConsole.log('[rewardedVideoPlayer] begin play'); this._playState = 'playing'; let playRes = await new Promise((resolve, reject)=&gt;{ let closeHandler = (status)=&gt;{ let isEnded = (status &amp;&amp; status.isEnded || status === undefined); this._rewardedVideo.offClose(closeHandler); resolve({code: 0, isEnded, errMsg: 'ok'}); }; this._rewardedVideo.onClose(closeHandler); this._rewardedVideo.show().catch((e)=&gt;{ console.error('[rewardedVideoPlayer] play failed, exception:', e); resolve({code: -3, errMsg: '播放异常', isEnded: false}); }); }); debugConsole.log('[rewardedVideoPlayer] finish play, res:', playRes); //结果处理 this._playState = playRes.code===0&amp;&amp;playRes.isEnded ? 'ended' : 'aborted'; this.load({reset: true}); //开始后台加载下一个视频（不管播没播完，都需要重新加载） return playRes; } /** * 监听加载状态变化，用于展示/隐藏入口等 * @param {Function} handler 监听函数，入参：{ state:'loaded', //加载状态，可选值及语义参见_loadStateValue定义处注释 } */ onLoadStateChange(handler){ if (typeof handler !== 'function') return; handler({state: this._loadState}); this._loadStateChangeListeners.push(handler); } /** * 获取当前加载状态（只读） */ get loadState(){ //供外部调用，只读 return this._loadStateValue; } get _loadState(){ //内部使用，可读可写 return this._loadStateValue; } set _loadState(newState){ //内部使用，可读可写 if (this._loadState === newState) return; this._loadStateValue = newState; this._loadStateChangeListeners.forEach(listener=&gt;listener({state: newState})); } get _playState(){ return this._playStateValue; } set _playState(newState){ this._playStateValue = newState; } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"decorator_noConcurrent.js.html":{"id":"decorator_noConcurrent.js.html","title":"Source: decorator/noConcurrent.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: decorator/noConcurrent.js /** * 免并发修饰器，在上一次操作结果返回之前，不响应重复操作 * e.g. * 用户连续多次点击同一个提交按钮，希望只响应一次，而不是同时提交多份表单 */ export const noConcurrent = makeNoConcurrent({mode: 'discard'}); /** * 步骤并合修饰器，避免公共步骤重复并发执行 * 将公共步骤单例化：若步骤未在进行，则发起该步骤；若步骤正在进行，则监听并使用其执行结果，而不是重新发起该步骤 * e.g. * 页面内同时发生如下三个请求： 登录-发送接口A、登录-发送接口B、登录-发送接口C * 未使用本修饰器时，网络时序：登录，登录，登录 - 接口A，接口B，接口C， 登录请求将会被发送三次 * 使用本修饰器时，网络时序：登录 - 接口A，接口B，接口C，登录请求只会被发送一次 */ export const mergingStep = makeNoConcurrent({mode: 'merge'}); /** * 单通道修饰器，使得并发调用逐个顺序执行 * e.g. * 页面中多处同时调用弹窗函数 * 未使用本修饰器时，执行时序：弹窗1、弹窗2、弹窗3同时展现，用户同时看到多个弹窗堆在一起and/or弹窗相互覆盖 * 使用本修饰器时，执行时序：弹窗1展现、等待交互、用户关闭 =&gt; 弹窗2展现、等待交互、用户关闭 =&gt; 弹窗3展现、等待交互、用户关闭，弹窗函数依次顺序执行 */ export const singleAisle = makeNoConcurrent({mode: 'wait'}); /** * 免并发修饰器模板 * @param {string} mode 互斥模式： * discard - 丢弃模式，无视后续并发操作，场景示例：用户连续快速多次点击同一按钮，只执行一次监听函数，无视后续并发点击； * merge - 合并模式，共享执行结果，场景示例：页面中多处同时触发登录过程，只执行一次登录流程，后续并发请求直接共享该次登录流程执行结果； * wait - 等待模式，依次顺序执行，场景示例：页面中多处同时调用弹窗函数，一次只展示一个弹窗，用户关闭后再展示第二个，依次顺序展示 * @param {*} discardRes （丢弃模式）被丢弃时函数返回结果 * * 说明： * 同步函数由于js的单线程特性没有并发问题，无需使用此修饰器 * 异步时序，为便于区分操作结束时机，此修饰器只支持修饰async函数/返回值为Promise的函数 */ export function makeNoConcurrent({mode, discardRes}) { return _noConcurrentTplt.bind(null, {mutexStore:'_noConCurrentLocks', mode, discardRes}); } /** * 多函数免并发，具有相同互斥标识的函数不会并发执行 * @param {Object} namespace 互斥函数间共享的一个全局变量，用于存储并发信息 * @param {string} mutexId 互斥标识，具有相同标识的函数不会并发执行 * @param {string} mode 互斥模式： * discard - 丢弃模式（默认），无视后续并发操作，场景示例：用户连续快速多次点击同一按钮，只执行一次监听函数，无视后续并发点击； * merge - 合并模式，共享执行结果，场景示例：页面中多处同时触发登录过程，只执行一次登录流程，后续并发请求直接共享该次登录流程执行结果； * wait - 等待模式，依次顺序执行，场景示例：页面中多处同时调用弹窗函数，一次只展示一个弹窗，用户关闭后再展示第二个，依次顺序展示 * @param {*} discardRes （丢弃模式）被丢弃时函数返回结果 * * 使用示例： * import {makeMutex} from 'fancy-mini/lib/decorators'; * let globalStore = {}; * class Navigator { @makeMutex({namespace:globalStore, mutexId:'navigate'}) //避免跳转相关函数并发执行 static async navigateTo(route){...} @makeMutex({namespace:globalStore, mutexId:'navigate'}) //避免跳转相关函数并发执行 static async navigateToMiniProgram(route){...} * } */ export function makeMutex({namespace, mutexId, mode, discardRes}) { if (typeof namespace !== \"object\") { console.error('[makeNoConcurrent] bad parameters, namespace shall be a global object shared by all mutex funcs, got:', namespace); return function () {} } return _noConcurrentTplt.bind(null, {namespace, mutexStore:'_noConCurrentLocksNS', mutexId, mode, discardRes}); } /** * 免并发修饰器通用模板 * @param {Object} namespace 互斥函数间共享的一个全局变量，用于存储并发信息，多函数互斥时需提供；单函数自身免并发无需提供，以本地私有变量实现 * @param {string} mutexStore 在namespace中占据一个变量名用于状态存储 * @param {string} mutexId 互斥标识，具有相同标识的函数不会并发执行，缺省值：函数名 * @param {string} mode 互斥模式： * discard - 丢弃模式（默认），无视后续并发操作，场景示例：用户连续快速多次点击同一按钮，只执行一次监听函数，无视后续并发点击； * merge - 合并模式，共享执行结果，场景示例：页面中多处同时触发登录过程，只执行一次登录流程，各并发请求直接共享该次登录流程执行结果； * wait - 等待模式，依次顺序执行，场景示例：页面中多处同时调用弹窗函数，一次只展示一个弹窗，用户关闭后再展示第二个，依次顺序展示 * @param {*} discardRes （丢弃模式）被丢弃时函数返回结果 * @param target * @param funcName * @param descriptor * @private */ function _noConcurrentTplt({namespace={}, mutexStore='_noConCurrentLocks', mutexId, mode='discard', discardRes=undefined}, target, funcName, descriptor) { namespace[mutexStore] = namespace[mutexStore] || {}; mutexId = mutexId || funcName; namespace[mutexStore][mutexId] = namespace[mutexStore][mutexId] || { running: false, //是否有实例正在执行 /** * 监听队列，当前函数实例执行完毕时调用 * Array&lt;Object&gt; { * block: false, //是否需要继续保持免并发状态 * handler: null, //处理函数，入参：刚结束的函数实例执行结果 * } */ listeners: [], }; let oriFunc = descriptor.value; descriptor.value = async function () { let statusControl = namespace[mutexStore][mutexId]; //免并发处理 if (statusControl.running) { //上一次操作尚未结束 switch (mode) { case 'discard': //丢弃模式，无视本次调用 return discardRes; case 'merge': //合并模式，直接使用上次操作结果作为本次调用结果返回 let lastRes = await new Promise((resolve,reject)=&gt;{ statusControl.listeners.push({ block: false, //无需继续免并发状态 handler: resolve, }); }); return lastRes; case 'wait': //等待模式，等待上次操作结束后再开始本次操作 await new Promise((resolve,reject)=&gt;{ statusControl.listeners.push({ block: true, //继续保持免并发状态 handler: resolve, }); }); break; default: console.error('[_noConcurrentTplt] unknown mode:', mode); return; } } //释放并发锁处理 let handleRunFinish = async function (res) { while (statusControl.listeners.length &gt; 0){ let listener = statusControl.listeners[0]; statusControl.listeners = statusControl.listeners.slice(1); listener.handler(res); if (listener.block) //阻塞性监听，则继续保持免并发状态；本轮处理结束，后续监听处理及互斥锁释放过程由监听函数接管 return; //否则继续进行后续监听处理 } statusControl.running = false; //监听函数全部处理完毕，则释放并发锁 return; }; //操作开始 statusControl.running = true; let res = oriFunc.apply(this, arguments); if (res instanceof Promise) res.then(()=&gt;{ handleRunFinish(res); }).catch((e)=&gt; { console.error(funcName, e); handleRunFinish(res); }); else { console.error('noConcurrent decorator shall be used with async function, yet got sync usage:', funcName); handleRunFinish(res); } return res; } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"request_Requester.js.html":{"id":"request_Requester.js.html","title":"Source: request/Requester.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: request/Requester.js import {makeAssignableMethod} from '../operationKit'; /** * @typedef {Object} ReqRes 接口请求结果 * @property {boolean} succeeded 请求是否成功（服务器返回即算成功，包括404/500等，网络异常等导致请求未正常返回才算失败） * @property {string|Object|Arraybuffer} [data] 开发者服务器返回的数据 * @property {number} [statusCode] 开发者服务器返回的 HTTP 状态码 * @property {Object} [header] 开发者服务器返回的 HTTP Response Header * @property {string} [errMsg] 错误信息 */ /** * 请求管理器，负责对接口请求进行各种封装处理 */ export default class Requester{ _underlayRequest = null; //底层网络api，功能格式同wx.request _plugins = []; //插件列表 /** * 构造函数 * @param {Object} [configOptions] */ constructor(configOptions){ configOptions &amp;&amp; this.config(configOptions); } config(configOptions){ const defaultOpts = { underlayRequest: wx.request, plugins: [], }; configOptions = Object.assign({}, defaultOpts, configOptions); this._underlayRequest = configOptions.underlayRequest; this._plugins = configOptions.plugins; for (let plugin of this._plugins) { plugin.mount({ requester: this, }); } } /** * 发送请求，供外部调用 * @public * @param {Object} reqOptions * @param {Object} [manageOptions] * @return {Promise&lt;ReqRes|ReqRes.data&gt;} 成功时返回接口数据，失败时返回完整请求结果 */ async request(reqOptions, manageOptions={}){ //保存回调（兼容起见支持回调，但更建议直接使用Promise） let {success, fail, complete} = reqOptions; delete reqOptions.success; delete reqOptions.fail; delete reqOptions.complete; //发出请求 let reqRes = await this._request({ reqOptions, manageOptions: { thisIssuer: manageOptions.thisIssuer, } }); //处理回调 if (reqRes.succeeded) { success &amp;&amp; success(reqRes); complete &amp;&amp; complete(reqRes); } else { fail &amp;&amp; fail(reqRes); complete &amp;&amp; complete(reqRes); } //返回结果 return reqRes.succeeded ? Promise.resolve(reqRes.data) : Promise.reject(reqRes); } /** * 在requester对象上注册方法，用于提供便捷调用 * e.g.注册requestWithLogin方法便于直接进行需要登录态的接口调用 * @param {string} methodName 方法名 * @param {Function} methodFunc 方法函数 */ registerToThis({methodName, methodFunc}){ if (this[methodName]) { console.error(`[requester] registerToThis failed, method:\"${methodName}\" already exist`); return; } this[methodName] = methodFunc; } /** * @param reqOptions * @param {Object} manageOptions * @param {boolean} manageOptions.disableRetry * @param {Object} manageOptions.thisIssuer * @return {Promise&lt;ReqRes&gt;} * @private */ async _request({reqOptions, manageOptions={}}){ //参数处理 const defaultManageOpts = { disableRetry: false, }; manageOptions = Object.assign({}, defaultManageOpts, manageOptions); //执行各插件的beforeRequest/beforeRequestAsync钩子函数 let beforeRes = await this._beforeRequest({reqOptions, manageOptions}); switch (beforeRes.action) { case 'cancel': let errMsg = `cancelled by plugin \"${beforeRes.plugin.pluginName}\" before request issued，reason: ${beforeRes.errMsg}`; console.warn('[Requester] 接口请求被取消，errMsg:', errMsg, 'url:', reqOptions.url); return { succeeded: false, errMsg, }; case 'continue': break; default: console.error('[Requester] dealing with beforeRes, unknown action:', beforeRes.action); } //调用接口 let reqRes = await this._doRequest({reqOptions, manageOptions}); //执行各插件的afterRequest/afterRequestAsync钩子函数 let afterRes = await this._afterRequest({reqOptions, reqRes, manageOptions}); switch (afterRes.action) { case 'retry': return manageOptions.disableRetry ? reqRes : this._request({ reqOptions, manageOptions: { ...manageOptions, disableRetry: true, //只允许重试一次，避免死循环 } }); case 'override': return afterRes.overrideRes; case 'continue': return reqRes; default: console.error('[Requester] dealing with afterRes, unknown action:', afterRes.action); return reqRes; } } async _beforeRequest({reqOptions, manageOptions}){ let finalRes = {action: 'continue'}; for (let plugin of this._plugins) { //调用钩子函数 let pluginRes = await this._execPluginHook({ plugin, hook: 'beforeRequest', args: {reqOptions}, defaultRes: {action: 'continue'}, manageOptions, }); //处理返回结果 switch (pluginRes.action) { case 'continue': break; case 'cancel': finalRes = {action: 'cancel', plugin, errMsg: pluginRes.errMsg}; return finalRes; default: console.error('[Requester] beforeRequest/beforeRequestAsync, unknown action:', pluginRes.action, 'pluginName:', plugin.pluginName); } } return finalRes; } /** * 调用接口 * @param reqOptions * @param manageOptions * @return {Promise&lt;ReqRes&gt;} * @private */ async _doRequest({reqOptions, manageOptions}){ return await new Promise((resolve)=&gt;{ this._underlayRequest({ ...reqOptions, success(res){ resolve(Object.assign({succeeded: true}, res)) }, fail(res){ resolve(Object.assign({succeeded: false}, res)) }, complete: null, }); }); } async _afterRequest({reqOptions, reqRes, manageOptions}){ let finalRes = {action: 'continue'}; for (let plugin of this._plugins) { //调用钩子函数 let pluginRes = await this._execPluginHook({ plugin, hook: 'afterRequest', args: {reqOptions, reqRes}, defaultRes: {action: 'continue'}, manageOptions, }); //处理返回结果 switch (pluginRes.action) { case 'continue': break; case 'override': finalRes = { action: 'override', overrideRes: pluginRes.overrideRes }; reqRes = finalRes.overrideRes; break; case 'retry': finalRes = {action: 'retry'}; return finalRes; default: console.error('[Requester] afterRequest/afterRequestAsync, unknown action:', pluginRes.action, 'pluginName:', plugin.pluginName); } } return finalRes; } async _execPluginHook({plugin, hook, args, defaultRes, manageOptions}){ //补充公共参数 args = { ...args, thisIssuer: manageOptions.thisIssuer, }; //执行插件钩子 let syncRes = null, asyncRes = null; try { syncRes = plugin[hook] ? plugin[hook](args) : null; asyncRes = plugin[`${hook}Async`] ? await plugin[`${hook}Async`](args) : null; } catch (e) { console.error(`[Requester] ${hook}/${hook}Async, caught error:`, e, 'pluginName:', plugin.pluginName); syncRes = null; asyncRes = null; } //返回执行结果 return Object.assign({}, defaultRes, syncRes, asyncRes); } /** * 将方法封装为通用函数，使之可以在任意this对象上执行 * @param {String} methodName 方法名 * @return {Function} 封装后的函数 */ makeAssignableMethod(methodName){ return makeAssignableMethod({ instance: this, method: methodName, rcvThis: { argIdx: 1, argProp: 'thisIssuer' } }) } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"EventHub.js.html":{"id":"EventHub.js.html","title":"Source: EventHub.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: EventHub.js /** * 事件中心，用于跨组件/跨页面事件通信 */ export default class EventHub { _validEvents = []; //事件列表 _listeners = []; //监听列表 /** * 构造函数 * @param {Array&lt;string&gt;} validEvents 配置的事件列表 */ constructor({validEvents}){ if (!Array.isArray(validEvents)) { console.error('[EventHub] bad param, validEvents shall be Array&lt;string&gt;'); return; } this._validEvents = validEvents; } /** * 监听指定事件 * @param {string} eventType 事件类型 * @param {function} handler 监听函数 * @param {string} persistType 持续策略：once-触发一次后自动移除 | always-每次都触发 */ subscribe({eventType, handler, persistType='once'}){ if (!(this._validEvents.includes(eventType))) { console.error('[EventHub] subscribe，试图监听无效事件：', eventType, '有效事件列表：', this._validEvents); return; } this._listeners.push({ eventType, handler, triggerCount: 0, //触发了几次 limitCount: persistType==='once' ? 1 : 0, //最多触发几次，0表示不限 }); } /** * 触发指定事件 * @param {string} eventType 事件类型 * @param {*} data 传递给监听函数的数据 */ notify({eventType, data}){ if (!(this._validEvents.includes(eventType))) { console.error('[EventHub] notify，试图触发无效事件：', eventType, '有效事件列表：', this._validEvents); return; } //监听回调 this._listeners.forEach(listener=&gt;{ if (listener.eventType === eventType) { listener.handler(data); ++ listener.triggerCount; } }); //移除达到回调上限的监听函数 this._listeners = this._listeners.filter(listener=&gt;!(listener.limitCount&gt;0 &amp;&amp; listener.limitCount&lt;=listener.triggerCount)); } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"canvasKit.js.html":{"id":"canvasKit.js.html","title":"Source: canvasKit.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: canvasKit.js export default { /** * 绘制图片，保持宽高比居中裁剪，短边完全展示，长边居中截取 * @param ctx wx.createCanvasContext返回的canvas绘图上下文 * @param picFile 图片临时文件路径 * @param picInfo wx.getImageInfo返回的图片原始信息 * @param x 左上角横坐标 * @param y 左上角纵坐标 * @param w 宽度 * @param h 高度 * @param bgColor 背景色，裁剪后多余部分用背景色擦除 * 说明： * 1.应先绘制图片，后填充图片周边内容，否则图片周边长边方向内容可能会被部分擦除 * 2.在开发者工具上图片多余部分无法被清除，但在真机上正常 * */ aspectFill({ctx, picFile, picInfo, x, y, w, h, bgColor=\"#ffffff\"}){ let aspect = picInfo.width / picInfo.height; //图片宽高比 let [dx, dy, dw, dh] = [0, 0, 0, 0]; //整张图片绘制位置 let extras = []; //需擦除的多余区域 if (aspect &lt; w/h) { dw = w; dh = dw/aspect; dx = x; dy = y - (dh-h)/2; extras = [[dx-1, dy-1, dw+2, (dh-h)/2+1], [dx-1, dy+(dh-h)/2+h, dw+2, (dh-h)/2+1]]; //为避免残余半像素的细线，擦除方向多加1px } else { dh = h; dw = dh*aspect; dx = x - (dw-w)/2; dy = y; extras = [[dx-1, dy-1, (dw-w)/2+1, dh+2], [dx+(dw-w)/2+w, dy-1, (dw-w)/2+1, dh+2]];//为避免残余半像素的细线，擦除方向多加1px } ctx.drawImage(picFile, dx, dy, dw, dh); //保持宽高比，缩放至指定区域后，绘制整张图片 ctx.save(); ctx.setFillStyle(bgColor); for (let extra of extras) { //擦除整张图片中多余区域 let [ex, ey, ew, eh] = extra; if (ex+ew &lt;= 0 || ey+eh&lt;=0) continue; if (ex &lt; 0) { ew -= Math.abs(ex); ex = 0; } if (ey &lt; 0) { eh -= Math.abs(ey); ey = 0; } ctx.fillRect(ex, ey, ew, eh); } ctx.restore(); }, /** * 将方形区域切成圆形，场景示例：将头像切成圆形展示 * @param ctx wx.createCanvasContext返回的canvas绘图上下文 * @param x 左上角横坐标 * @param y 左上角纵坐标 * @param w 宽度/高度/圆的直径 * @param bgColor 背景色，擦除部分以背景色填充 */ rounded({ctx, x, y, w, bgColor=\"#ffffff\"}){ ctx.save(); ctx.translate(x, y); ctx.beginPath(); ctx.moveTo(w, w/2); ctx.arc(w/2,w/2,w/2,0,2*Math.PI, false); ctx.lineTo(w, 0); ctx.lineTo(0, 0); ctx.lineTo(0, w); ctx.lineTo(w, w); ctx.closePath(); ctx.setFillStyle(bgColor); ctx.fill(); ctx.restore(); }, /** * 将矩形切成圆角矩形 * @param ctx wx.createCanvasContext返回的canvas绘图上下文 * @param x 矩形左上角横坐标 * @param y 矩形左上角纵坐标 * @param w 矩形宽度 * @param h 矩形高度 * @param radius 圆角半径 * @param bgColor 背景色，擦除部分以背景色填充 */ borderRadius({ctx, x, y, w, h, radius, bgColor=\"#ffffff\"}){ ctx.save(); ctx.translate(x, y); ctx.setFillStyle(bgColor); //擦除左上角多余部分 ctx.beginPath(); ctx.moveTo(0, 0+radius); ctx.quadraticCurveTo(0, 0, 0+radius, 0); ctx.lineTo(0, 0); ctx.closePath(); ctx.fill(); //擦除右上角多余部分 ctx.beginPath(); ctx.moveTo(w-radius, 0); ctx.quadraticCurveTo(w, 0, w, radius); ctx.lineTo(w, 0); ctx.closePath(); ctx.fill(); //擦除右下角角多余部分 ctx.beginPath(); ctx.moveTo(w-radius, h); ctx.quadraticCurveTo(w, h, w, h-radius); ctx.lineTo(w, h); ctx.closePath(); ctx.fill(); //擦除左下角多余部分 ctx.beginPath(); ctx.moveTo(0, h-radius); ctx.quadraticCurveTo(0, h, 0+radius, h); ctx.lineTo(0, h); ctx.closePath(); ctx.fill(); ctx.restore(); }, /** * 绘制文本，支持\\n换行 * @param ctx wx.createCanvasContext返回的canvas绘图上下文 * @param text 文本内容，支持\\n换行 * @param x 文本区域（含行高）左上角横坐标；居中对齐时，改取中点横坐标 * @param y 文本区域（含行高）左上角纵坐标 * @param fontSize 字号，单位：px * @param color 颜色 * @param lineHeight 行高 * @param textAlign 水平对齐方式，支持'left'、'center'，其它值没试过 */ fillText(ctx, {text, x, y, fontSize, color, lineHeight, textAlign}){ ctx.save(); lineHeight = lineHeight || fontSize; fontSize &amp;&amp; ctx.setFontSize(fontSize); color &amp;&amp; ctx.setFillStyle(color); textAlign &amp;&amp; ctx.setTextAlign(textAlign); let lines = text.split('\\n'); for (let line of lines) { ctx.fillText(line, x, y+lineHeight-(lineHeight-fontSize)/2); y += lineHeight; } ctx.restore(); }, /** * 字符串过长截断，1个字母长度计为1,1个汉字长度计为2 * @param {string} str 原字符串 * @param {number} len 最大长度 * @param {boolean} ellipsis 过长时截断后是否加'...' * @return {string} 截断后字符串 */ ellipsisStr(str, len, ellipsis=true) { var str_length = 0; var str_len = 0; var str_cut = new String(); str_len = str.length; for (var i = 0; i &lt; str_len; i++) { let a = str.charAt(i); str_length++; if (escape(a).length &gt; 4) { //中文字符的长度经编码之后大于4 str_length++; } str_cut = str_cut.concat(a); if (str_length &gt;= len) { str_cut = str_cut.concat(ellipsis&amp;&amp;(str_length&gt;len || i+1&lt;str_len) ? \"...\" : \"\"); return str_cut; } } //如果给定字符串小于指定长度，则返回源字符串； if (str_length &lt; len) { return str; } }, /** * 字符串长度，1个字母长度计为1,1个汉字长度计为2 * canvas目前似乎不支持获取文本绘制后所占宽度，只能根据字数粗略计算了 */ strLenGraphic(str) { var str_length = 0; for (var i = 0; i &lt; str.length; i++) { let a = str.charAt(i); str_length++; if (escape(a).length &gt; 4) { //中文字符的长度经编码之后大于4 str_length++; } } return str_length; } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"request_plugin_LoginPlugin.js.html":{"id":"request_plugin_LoginPlugin.js.html","title":"Source: request/plugin/LoginPlugin.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: request/plugin/LoginPlugin.js import BasePlugin from \"./BasePlugin\"; import {makeAssignableMethod} from '../../operationKit'; export default class LoginPlugin extends BasePlugin{ loginCenter = null; apiAuthFailChecker = null; constructor({pluginName, loginCenter, apiAuthFailChecker}){ super({ pluginName: pluginName || 'LoginPlugin' }); this.loginCenter = loginCenter; this.apiAuthFailChecker = apiAuthFailChecker; } mount(...args){ super.mount(...args); this.requester.registerToThis({ methodName: 'requestWithLogin', methodFunc: makeAssignableMethod({ instance: this, method: 'requestWithLogin', rcvThis: { argIdx: 1, argProp: 'thisIssuer' } }), }); } /** * http请求，封装了登录逻辑，保证调用接口时具有登录态 * @param {Object} reqOptions 调用参数，格式同request * @param {Object} reqOptions.loginOpts 登录参数，格式同login * @param {Object} [manageOptions] 管理参数，格式同request * @return {Promise} 请求结果，格式同request */ async requestWithLogin(reqOptions, manageOptions={}){ reqOptions.needLogin = true; return this.requester.request(reqOptions, manageOptions); } async beforeRequestAsync({reqOptions, thisIssuer}){ //检查是否需要登录态 if (!reqOptions.needLogin) return; //获取登录态 let loginRes = await this.loginCenter.login(reqOptions.loginOpts, {thisIssuer}); //判断是否需要取消接口调用 return (loginRes.code===0 || loginRes.code===-200) ? {action: 'continue'} : {action: 'cancel', errMsg: '登录失败'}; } async afterRequestAsync({reqOptions, reqRes, thisIssuer}){ //检查是否需要登录态 if (!reqOptions.needLogin) return; //判断后端登录态是否失效 let isAuthFail = this.apiAuthFailChecker(reqRes.data, reqOptions); //未失效，正常返回请求结果 if (!isAuthFail) return; //已失效，清除前端登录态 this.loginCenter.clearLogin(); //重新登录，重新发送接口请求，以重新请求的结果作为本次调用结果返回 return { action: 'retry', } } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"routeParams.js.html":{"id":"routeParams.js.html","title":"Source: routeParams.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: routeParams.js import {deepEqual} from './operationKit'; /** * 用于页面间传递参数 * 场景一： * 后一页面返回数据给前一页面，如：A页面-点击“选择地址”-地址页-选择完毕返回A页面，此时需将选择结果传给A页面 * 场景二： * 前一页面传递参数给后一页面，一般直接在url中加参数即可，但若数据复杂，亦可考虑使用此数据对象进行传递 * 利用ES6导出的是符号连接特性，不同页面引入的是同一实例，A页面对数据进行操作，B页面即时生效，因而可当作全局数据对象使用 * 相比于使用storage传参，此方式为内存操作，即时性更强，效率更高 * 相比于直接调用前一页面的指定成员方法，此方式更通用，页面间耦合性更低 */ class RouteParams { _backFromRoute = ''; //后一页面（backFrom）路由 _backFromData = ''; //后一页面传递给前一页面的数据 _backFromHistoryStack = []; //后一页面路由栈，用于校验层级关系，避免backFrom数据未及时清理，对其它页面造成持续干扰 _openFromRoute = ''; //前一页面（openFrom）路由 _openFromData = ''; //前一页面传递给后一页面的数据 _openFromHistoryStack = []; //前一页面路由栈，用于校验层级关系，避免openFrom数据未及时清理，对其它页面造成持续干扰 static _getHistorySnapShot(history=getCurrentPages()){ return history.map(page=&gt;page.route||page.__route__); } /** * 后一页面向前一页面传递数据 * @param {*} data 数据内容 */ setBackFromData(data){ let history = getCurrentPages(); let curPage = history[history.length-1]; this._backFromRoute = curPage.route || curPage.__route__; this._backFromData = data; this._backFromHistoryStack = RouteParams._getHistorySnapShot(history); } /** * 返回前一页面时，获取后一页面的页面路径 * @return {string} 后一页面页面路径 */ getBackFromRoute(){ let curStack = RouteParams._getHistorySnapShot(); if (!(curStack.length===this._backFromHistoryStack.length-1 &amp;&amp; deepEqual(curStack, this._backFromHistoryStack.slice(0,-1)))) //路由栈不匹配，说明此为n久前其它页面遗留数据，应予以清理 this.clearBackFrom(); return this._backFromRoute; } /** * 返回前一页面时，获取后一页面传递过来的数据 * @return {string} 后一页面传递过来的数据 */ getBackFromData(){ let curStack = RouteParams._getHistorySnapShot(); if (!(curStack.length===this._backFromHistoryStack.length-1 &amp;&amp; deepEqual(curStack, this._backFromHistoryStack.slice(0,-1)))) //路由栈不匹配，说明此为n久前其它页面遗留数据，应予以清理 this.clearBackFrom(); return this._backFromData; } /** * 清除后一页面向前一页面的传递内容 */ clearBackFrom(){ this._backFromRoute = ''; this._backFromData = ''; } /** * 前一页面向后一页面传递数据 * @param {*} data 数据内容 */ setOpenFromData(data){ let history = getCurrentPages(); let curPage = history[history.length-1]; this._openFromRoute = curPage.route || curPage.__route__; this._openFromData = data; this._openFromHistoryStack = RouteParams._getHistorySnapShot(history); } /** * 进到后一页面时，获取前一页面的页面路径 * @return {string} 前一页面页面路径 */ getOpenFromRoute(){ let curStack = RouteParams._getHistorySnapShot(); let hisMatch = (curStack.length===this._openFromHistoryStack.length+1 &amp;&amp; deepEqual(curStack.slice(0,-1), this._openFromHistoryStack)) || //navigateTo (curStack.length===this._openFromHistoryStack.length &amp;&amp; deepEqual(curStack.slice(0,-1), this._openFromHistoryStack.slice(0,-1))); //redirectTo if (!hisMatch) //路由栈不匹配，说明此为n久前其它页面遗留数据，应予以清理 this.clearOpenFrom(); return this._openFromRoute; } /** * 进到后一页面时，获取前一页面传递过来的数据 * @return {string} 前一页面传递过来的数据 */ getOpenFromData(){ let curStack = RouteParams._getHistorySnapShot(); let hisMatch = (curStack.length===this._openFromHistoryStack.length+1 &amp;&amp; deepEqual(curStack.slice(0,-1), this._openFromHistoryStack)) || //navigateTo (curStack.length===this._openFromHistoryStack.length &amp;&amp; deepEqual(curStack.slice(0,-1), this._openFromHistoryStack.slice(0,-1))); //redirectTo if (!hisMatch) //路由栈不匹配，说明此为n久前其它页面遗留数据，应予以清理 this.clearOpenFrom(); return this._openFromData; } /** * 清除前一页面向后一页面的传递内容 */ clearOpenFrom(){ this._openFromRoute = ''; this._openFromData = ''; } } export default new RouteParams(); × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"decorator_compatible.js.html":{"id":"decorator_compatible.js.html","title":"Source: decorator/compatible.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: decorator/compatible.js /** * 提供微信api形式的回调 * 主要适用场景：将微信api改写为promise形式后，兼容旧代码 * 被修饰函数应该返回一个promise，成功时resolve，失败时reject，或返回{succeeded: true/false, ...}格式，通过succeeded字段标识成功失败 * 修饰后的函数会支持arguments[0]中传入success、fail、complete属性，并根据promise结果进行回调 * @param target * @param funcName * @param descriptor */ export function supportWXCallback(target, funcName, descriptor) { let oriFunc = descriptor.value; descriptor.value = function (...args) { //获取回调函数 let {success, fail, complete} = args[0] || {}; //获取执行结果 let fetchRes = oriFunc.apply(this, args); //格式检查 if (!(fetchRes instanceof Promise)) { console.error('[supportWXCallback] 被修饰函数返回结果应为Promise，函数：', funcName); return fetchRes; } //触发回调 fetchRes.then((...results)=&gt;{ //判断应该按成功回调还是按失败回调 let succeeded = results[0] &amp;&amp; typeof results[0].succeeded === \"boolean\" ? results[0].succeeded : true; //回调 if (succeeded) { success &amp;&amp; success(...results); } else { fail &amp;&amp; fail(...results); } complete &amp;&amp; complete(...results); }); fetchRes.catch((e)=&gt;{ let res = { errMsg: (e instanceof Error) ? e.message : (e &amp;&amp; e.errMsg) ? e.errMsg : (typeof e ===\"string\") ? e : 'fail' }; fail &amp;&amp; fail(res); complete &amp;&amp; complete(res); }); //保留promise调用形式 return fetchRes; } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"AdaptiveToast.js.html":{"id":"AdaptiveToast.js.html","title":"Source: AdaptiveToast.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: AdaptiveToast.js import {delay, deepAssign} from './operationKit'; class Toast { _options = { icons: { success: '/images/tipsucc.png', fail: '/images/tipfail.png' }, defaultOpts: { title: '', type: 'fail', duration: 2000, }, installProps: { '$toast': 'toast' } }; constructor(options){ deepAssign(this._options, options); } get installProps(){ return this._options.installProps; } /** * toast * @param {Object} options { * title: '', //提示文案 * type: '', //图标类型：'success' | 'fail' * duration: 2000, //持续时长， 单位：ms * } */ toast = async (options)=&gt;{ options = Object.assign({}, this._options.defaultOpts, options); let len = options.title.length; if (len &lt;= 7) //文案简洁，使用带图标的toast return this.sysToastIcon(options); else if (len &lt;= 20) //文案较长，使用长文本toast return this.sysToastText(options); else //文案巨长，改用弹窗 return this.sysToastModal(options); } /** * 使用微信系统toast，带图标，最多只能展示7个汉字 * @param options 同toast函数 */ sysToastIcon = async (options)=&gt;{ wx.showToast({ title: options.title, image: this._options.icons[options.type] || options.type, duration: options.duration, success : options.success, fail:options.fail, complete:options.complete }); await delay(options.duration); } /** * 使用微信系统toast，不带图标，最多展示两行 * @param options 同toast函数 */ sysToastText = async (options)=&gt;{ if (!wx.setTabBarItem) //不带图标的toast从基础库1.9.0开始支持；wx.canIUse('showToast.object.icon.none')不好使，暂借用其它API来判断版本 return this.sysToastModal(options); let title = options.title; /*if (!title.includes('\\n')) { //折成字数相等的两行 （安卓机下有时第一行会变成'...'不能正常展示，且与内容编码无关，纯英文字符串亦可复现；原因不明，暂去掉自动换行逻辑） let mid = Math.ceil(title.length/2); title = title.substring(0, mid)+'\\n'+title.substring(mid); }*/ wx.showToast({ title, icon: 'none', duration: options.duration, success : options.success, fail:options.fail, complete:options.complete }); await delay(options.duration); } /** * 使用微信系统弹窗，可以展示大片文案 * @param options 同toast函数 */ sysToastModal = async (options)=&gt;{ return new Promise((resolve, reject)=&gt;{ wx.showModal({ title: '提示', content: options.title, showCancel: false, confirmText: '知道了', success : options.success, fail:options.fail, complete: (...args)=&gt;{ options.complete &amp;&amp; options.complete(...args); resolve(); } }); }) } } export default Toast; × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"login_auth_WechatAuth.js.html":{"id":"login_auth_WechatAuth.js.html","title":"Source: login/auth/WechatAuth.js","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Source: login/auth/WechatAuth.js import BaseAuth from './BaseAuth'; import {wxPromise, wxResolve} from '../../wxPromise'; export default class WechatAuth extends BaseAuth{ async silentLogin({loginOptions, configOptions}){ let wxLoginRes = await this.wxLogin(); return this.loginByWxSilent({wxLoginRes, loginOptions, configOptions}); } async beforeAuthLogin({loginOptions, configOptions}){ let wxLoginRes = await this.wxLogin(); return {wxLoginRes}; } async authLogin({loginOptions, configOptions, beforeRes, authData}){ return this.loginByWxAuth({ wxLoginRes: beforeRes.wxLoginRes, authData, loginOptions, configOptions, }); } /** * 微信登录：调用微信相关API，获取用户标识（openid，某些情况下也能获得unionid） * @return {Promise&lt;Object&gt;} 微信用户标识 */ async wxLogin(){ return await wxResolve.login(); } async loginByWxSilent({wxLoginRes, loginOptions, configOptions}){ //根据wxLoginRes.code调后端接口获得用户信息 return { succeeded: false, errMsg: '请覆盖loginByWxSilent函数完成查询用户信息功能', toastMsg: '请覆盖loginByWxSilent函数完成查询用户信息功能', userInfo: {}, expireTime: -1, } } async loginByWxAuth({wxLoginRes, authData, loginOptions, configOptions}){ //根据wxLoginRes.code和authData调后端接口获得用户信息 return { succeeded: false, errMsg: '请覆盖loginByWxAuth函数完成注册/查询用户信息功能', toastMsg: '请覆盖loginByWxSilent函数完成查询用户信息功能', userInfo: {}, expireTime: -1, } } } × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Global Members correctLevel 自行维护的逻辑历史栈与系统实际历史栈的前若干项应当始终保持一致 Source: navigate/History.js &lt;constant&gt; ctxDependConsole 上下文相关的控制台：开启调试模式时，功能同系统console；关闭调试模式时，忽略所有console调用。调试模式开关由本模块自动获取/统一指定，对调用方透明。使用示例：import {ctxDependConsole as console} from '../../lib/debugKit'console.log('ha ha ha'); //开启调试模式时，打印'ha ha ha'；关闭调试模式时，自动无视此行代码 Source: debugKit.js curRoute 当前页面配置 Source: navigate/History.js history 完整历史记录 Source: navigate/Navigator.js length 历史栈长度 Source: navigate/History.js listeners 监听队列，当前函数实例执行完毕时调用Array { block: false, //是否需要继续保持免并发状态 handler: null, //处理函数，入参：刚结束的函数实例执行结果} Source: decorator/noConcurrent.js loadState 获取当前加载状态（只读） Source: RewardedVideoPlayer.js &lt;constant&gt; mergingStep 步骤并合修饰器，避免公共步骤重复并发执行将公共步骤单例化：若步骤未在进行，则发起该步骤；若步骤正在进行，则监听并使用其执行结果，而不是重新发起该步骤e.g.页面内同时发生如下三个请求： 登录-发送接口A、登录-发送接口B、登录-发送接口C未使用本修饰器时，网络时序：登录，登录，登录 - 接口A，接口B，接口C， 登录请求将会被发送三次使用本修饰器时，网络时序：登录 - 接口A，接口B，接口C，登录请求只会被发送一次 Source: decorator/noConcurrent.js &lt;constant&gt; NavRefine 支持prefetch等附加功能的路由模块，格式与wx保持一致 Source: wepyKit.js &lt;constant&gt; noConcurrent 免并发修饰器，在上一次操作结果返回之前，不响应重复操作e.g.用户连续多次点击同一个提交按钮，希望只响应一次，而不是同时提交多份表单 Source: decorator/noConcurrent.js pageRestoreHandler 自定义页面数据恢复函数，用于 wepy实例覆盖问题，存在两级同路由页面时，前者数据会被后者覆盖，返回时需予以恢复 层级过深时，新开页面会替换前一页面，导致前一页面数据丢失，返回时需予以恢复 Source: navigate/Navigator.js routes 完整历史记录 Source: navigate/History.js &lt;constant&gt; singleAisle 单通道修饰器，使得并发调用逐个顺序执行e.g.页面中多处同时调用弹窗函数未使用本修饰器时，执行时序：弹窗1、弹窗2、弹窗3同时展现，用户同时看到多个弹窗堆在一起and/or弹窗相互覆盖使用本修饰器时，执行时序：弹窗1展现、等待交互、用户关闭 =&gt; 弹窗2展现、等待交互、用户关闭 =&gt; 弹窗3展现、等待交互、用户关闭，弹窗函数依次顺序执行 Source: decorator/noConcurrent.js &lt;constant&gt; wxPromise 小程序API的Promise封装，用法与wx一致，只是返回结果为Promise形式示例： async func(){ let imgInfo = await wxPromise.getImageInfo({src: 'https://xxx'}); //调用wx.getImageInfo，并在success回调中resolve console.log(imgInfo.width); //打印图片信息 } Source: wxPromise.js &lt;constant&gt; wxResolve 同wxPromise，差别在于wxPromise在成功时resolve，失败时reject，而wxResolve不管成功失败都会resolve，便于手动处理异常情形示例： async func(){ let copyRes = await wxResolve.setClipboardData({ data: 'hello'}); //复制到剪贴板 this.$toast({ //成功失败均予以提示 title: copyRes.succeeded ? '复制成功' : '复制失败', type: copyRes.succeeded ? 'success' : 'fail', }); } Source: wxPromise.js Methods afterRequest(reqOptions, thisIssuer, reqRes) 钩子函数，请求返回之后调用，同步不会等待异步操作返回，如需等待异步逻辑，请改用afterRequestAsync Parameters: Name Type Description reqOptions Object 请求参数 thisIssuer * 发起请求的this对象 reqRes RequestRes 请求返回结果，除单独说明字段外，格式同wx.request回调结果 Properties Name Type Description succeeded boolean 请求成功/失败 Source: request/plugin/BasePlugin.js Returns: 期望的后续处理： undefined - 默认 { action: '', //后续处理：'continue'-继续 | 'override'-覆盖请求结果 | 'retry'-重新发送请求 overrideRes: {}, //action==='override'时，以该结果覆盖原来的请求结果 errMsg: '', //错误信息，解释操作原因，便于定位追溯 } Type undefined | Object Example afterRequest({reqOptions, thisIssuer}){ return { action: 'continue', errMsg: 'ok', } } afterRequestAsync(reqOptions, thisIssuer, reqRes) 钩子函数，请求返回之后调用，异步会等待async函数resolve，若无异步逻辑，建议使用afterRequest Parameters: Name Type Description reqOptions Object 请求参数 thisIssuer * 发起请求的this对象 reqRes RequestRes 请求返回结果，除单独说明字段外，格式同wx.request回调结果 Properties Name Type Description succeeded boolean 请求成功/失败 Source: request/plugin/BasePlugin.js Returns: 期望的后续处理： undefined - 默认 { action: '', //后续处理：'continue'-继续 | 'override'-覆盖请求结果 | 'retry'-重新发送请求 overrideRes: {}, //action==='override'时，以该结果覆盖原来的请求结果 errMsg: '', //错误信息，解释操作原因，便于定位追溯 } Type Promise.&lt;(undefined|{action: string, errMsg: string, overrideRes: RequestRes})&gt; Example async afterRequestAsync({reqOptions, thisIssuer}){ return { action: 'continue', errMsg: 'ok', } } appendUrlParam(url, extraParams) 拼接参数，注：当前只针对小程序标准url，暂未考虑含#号/多?号等特殊url情形 Parameters: Name Type Description url string 原url extraParams Object 新增参数 Source: operationKit.js Returns: 新url Type string authLogin(loginOptions, configOptions [, beforeRes], authData) 授权登录需要用户配合点击授权按钮/输入表单等才能完成的登录过程 Parameters: Name Type Argument Description loginOptions Object 登录函数调用参数 configOptions Object 登录模块配置参数 beforeRes * &lt;optional&gt; beforeAuthLogin钩子执行结果 authData Object 登录界面交互结果 Source: login/auth/BaseAuth.js Returns: Type Promise.&lt;{succeeded: boolean, errMsg: string, userInfo: {}, expireTime: number, anonymousInfo: {}}&gt; back(delta) 返回 Parameters: Name Type Description delta Number 返回级数 Source: navigate/History.js Returns: 返回完成后所处的页面配置 Type Object beforeAuthLogin(loginOptions, configOptions) 进行授权登录之前的准备工作时序：beforeAuthLogin -&gt; 用户交互，同意授权 -&gt; authLogin Parameters: Name Type Description loginOptions Object 登录函数调用参数 configOptions Object 登录模块配置参数 Source: login/auth/BaseAuth.js Returns: 需要传递给authLogin的数据 Type Promise.&lt;*&gt; beforeRequest(reqOptions, thisIssuer) 钩子函数，发请求之前调用，同步不会等待异步操作返回，如需等待异步逻辑，请改用beforeRequestAsync Parameters: Name Type Description reqOptions Object 请求参数 thisIssuer * 发起请求的this对象 Source: request/plugin/BasePlugin.js Returns: 期望的后续处理： undefined - 默认 { action: '', //后续处理：'cancel'-终止该请求 | 'continue'-继续发送 errMsg: '', //错误信息，解释拦截原因 } Type undefined | Object Example beforeRequest({reqOptions, thisIssuer}){ return { action: 'continue', errMsg: 'ok', } } beforeRequestAsync(reqOptions, thisIssuer) 钩子函数，发请求之前调用，异步会等待async函数resolve，若无异步逻辑，建议使用beforeRequest Parameters: Name Type Description reqOptions Object 请求参数 thisIssuer * 发起请求的this对象 Source: request/plugin/BasePlugin.js Returns: 期望的后续处理： undefined - 默认 { action: '', //后续处理：'cancel'-终止该请求 | 'continue'-继续发送 errMsg: '', //错误信息，解释拦截原因 } Type Promise.&lt;(undefined|{action: ('cancel'|'continue'), errMsg: string})&gt; Example async beforeRequestAsync({reqOptions, thisIssuer}){ return { action: 'continue', errMsg: 'ok', } } compareVersion(v1, v2) 版本号比较 Parameters: Name Type Description v1 string 版本号1，形如\"2.2.3\" v2 string 版本号2 Source: operationKit.js Returns: 比较结果： -1 小于 | 0 等于 | 1 大于 Type number config(options) 安装 Parameters: Name Type Description options Object 自定义配置，可配置项参见 _config 相关字段及注释 Source: navigate/Navigator.js cookieObjToStr(cookieObj) 将{key1: value1, key2: value2}的对象形式键值对转为'key1=value1;key2=value2'形式的cookie字符串 Parameters: Name Type Description cookieObj Object Source: Cookie.js Returns: cookieStr Type string cookieStrToObj(cookieStr) 将'key1=value1;key2=value2'形式的cookie字符串转为{key1: value1, key2: value2}的对象形式 Parameters: Name Type Description cookieStr string Source: Cookie.js Returns: cookieObj Type Object customWxPromisify(overrides, dealFail) 自定义Promise化方式 Parameters: Name Type Description overrides Object 自定义覆盖wx的部分接口 dealFail boolean true - 失败时也resolve，并标记res.succeeded=false； false - 失败时直接reject Source: wxPromise.js Returns: Promise化的wx Type Object dataRestoreWx2Wepy(compThis, data, compPrefix) 从原生页面数据中恢复wepy页面/组件实例数据 Parameters: Name Type Description compThis object wepy页面/组件根实例 data object 原生页面数据 compPrefix string 根实例数据在原生页面数据中的前缀，如： ''(页面实例）、'$PageFrame$'(页面下的PageFrame组件）、'$PageFrame$BackHome$'（PageFrame组件下的BackHome组件） Source: wepyKit.js Returns: void 会将根实例及其所有后代组件实例 数据恢复为与原生页面数据保持一致的状态 deepAssign(target, sources) 深度覆盖将源对象的值覆盖目标对象，相同结构相同参数部分直接覆盖，其它部分保持不变 Parameters: Name Type Description target 目标对象 sources 若干个源对象 Source: operationKit.js Example 修改前： target = {x: 1, y: {a: 1, b:1 }, z: 1}; source = {x: 2, y: {a: 2}}; 修改后： target = {x: 2, y: {a: 2, b:1 }, z: 1} deepClone(source) 深度拷贝 Parameters: Name Type Description source 源参数 Source: operationKit.js Returns: 源参数的深度拷贝 Type * deepEqual(o1, o2) 深度判等两个对象结构和数据完全一致，即认为相等，而不要求是同一引用 Parameters: Name Type Description o1 参数1 o2 参数2 Source: operationKit.js Returns: 参数1、参数2 是否相等 Type boolean delay(ms) 设置延时 Parameters: Name Type Description ms number 延迟时长，单位：ms Source: operationKit.js Returns: Type Promise doCorrection() 根据系统历史栈校正本地维护的历史记录考虑到实际路由场景过于复杂，故定期校正以增强健壮性，如：点击右上角主页按钮、退出后又点击另一个分享链接、页面未使用封装接口等 Source: navigate/History.js errSafe() 捕获函数异常，避免阻断主流程 Source: decorator/errSafe.js fullUrl(path, options) 将路径和参数拼成完整url Parameters: Name Type Description path 路径 options 参数 Source: navigate/History.js Returns: url Type string get( [key] [, options]) 读取指定cookiekey未传时，返回全部cookie Parameters: Name Type Argument Description key string &lt;optional&gt; 要读取的key options object &lt;optional&gt; 配置选项（暂未支持） Source: Cookie.js Returns: cookie中key对应的value | 未传key时，返回全部key-value组成的对象 Type string | object getCookie() 获取当前可访问的cookie字符串 Source: Cookie.js Returns: cookie字符串，形如：'key1=value1;key2=value2'（类似web中读取document.cookie） Type string handlePageChange(preload) 切换页面时原生视频实例失效，故每次onShow需重新初始化 Parameters: Name Type Description preload boolean 是否需要预加载视频：true-开始预加载 | false-不进行预加载（后续可手动调用load()决定加载时机） Source: RewardedVideoPlayer.js isNonEmptyObject(item) 判断一个变量是否为非空对象 Parameters: Name Type Description item Source: operationKit.js Returns: Type boolean isNonNullObject(item) 判断一个变量是否为非null对象 Parameters: Name Type Description item Source: operationKit.js Returns: Type boolean isSamePage(url1, url2) 判断两个url是否为同一个页面的实例 Parameters: Name Type Description url1 url2 Source: navigate/History.js Returns: Type boolean &lt;async&gt; load(reset) 开始加载视频 Parameters: Name Type Description reset boolean 是否需要重置：true-强制重新加载 | false-可复用已有视频 Source: RewardedVideoPlayer.js makeAssignableMethod(instance, method [, rcvThis]) 将实例方法封装为通用函数，使之可以在任何this对象上执行 Parameters: Name Type Argument Description instance Object 实例对象 method String 方法名 rcvThis Object | Boolean &lt;optional&gt; 保存触发源的this对象 Properties Name Type Argument Description argIdx Number &lt;optional&gt; 将this对象保存到下标为argIdx的参数的argProp属性上 argProp String &lt;optional&gt; 将this对象保存到下标为argIdx的参数的argProp属性上 Source: operationKit.js makeAssignableMethod(methodName) 将方法封装为通用函数，使之可以在任意this对象上执行 Parameters: Name Type Description methodName String 方法名 Source: request/Requester.js Returns: 封装后的函数 Type function makeMutex(namespace, mutexId, mode, discardRes) 多函数免并发，具有相同互斥标识的函数不会并发执行 Parameters: Name Type Description namespace Object 互斥函数间共享的一个全局变量，用于存储并发信息 mutexId string 互斥标识，具有相同标识的函数不会并发执行 mode string 互斥模式： discard - 丢弃模式（默认），无视后续并发操作，场景示例：用户连续快速多次点击同一按钮，只执行一次监听函数，无视后续并发点击； merge - 合并模式，共享执行结果，场景示例：页面中多处同时触发登录过程，只执行一次登录流程，后续并发请求直接共享该次登录流程执行结果； wait - 等待模式，依次顺序执行，场景示例：页面中多处同时调用弹窗函数，一次只展示一个弹窗，用户关闭后再展示第二个，依次顺序展示 discardRes * （丢弃模式）被丢弃时函数返回结果 使用示例：import {makeMutex} from 'fancy-mini/lib/decorators';let globalStore = {};class Navigator { Source: decorator/noConcurrent.js makeNoConcurrent(mode, discardRes) 免并发修饰器模板 Parameters: Name Type Description mode string 互斥模式： discard - 丢弃模式，无视后续并发操作，场景示例：用户连续快速多次点击同一按钮，只执行一次监听函数，无视后续并发点击； merge - 合并模式，共享执行结果，场景示例：页面中多处同时触发登录过程，只执行一次登录流程，后续并发请求直接共享该次登录流程执行结果； wait - 等待模式，依次顺序执行，场景示例：页面中多处同时调用弹窗函数，一次只展示一个弹窗，用户关闭后再展示第二个，依次顺序展示 discardRes * （丢弃模式）被丢弃时函数返回结果 说明： 同步函数由于js的单线程特性没有并发问题，无需使用此修饰器 异步时序，为便于区分操作结束时机，此修饰器只支持修饰async函数/返回值为Promise的函数 Source: decorator/noConcurrent.js mergeCookieStr(cookieStrs) 将'key1=value1;key2=value2'形式的cookie字符串合并，key相同时后面的覆盖前面的 Parameters: Name Type Argument Description cookieStrs string &lt;repeatable&gt; Source: Cookie.js mount(requester) 钩子函数，插件被挂载到requester对象上时被调用 Parameters: Name Type Description requester Requester 请求管理器 Source: request/plugin/BasePlugin.js &lt;async&gt; navigateBack(opts) 返回 Parameters: Name Type Description opts Object 返回配置，格式同wx.navigateBack Source: navigate/Navigator.js &lt;async&gt; navigateTo(route) 打开新页面 Parameters: Name Type Description route Object 页面配置，格式同wx.navigateTo Source: navigate/Navigator.js notify(eventType, data) 触发指定事件 Parameters: Name Type Description eventType string 事件类型 data * 传递给监听函数的数据 Source: EventHub.js onLoadStateChange(handler) 监听加载状态变化，用于展示/隐藏入口等 Parameters: Name Type Description handler function 监听函数，入参：{ state:'loaded', //加载状态，可选值及语义参见_loadStateValue定义处注释 } Source: RewardedVideoPlayer.js onPageUnload() 监听页面卸载过程；本质是想监听用户的返回操作（点击物理返回键/左上角返回按钮），但似乎并没有相应接口，暂借助页面onUnload过程进行判断 Source: navigate/Navigator.js open(route) 打开新页面 Parameters: Name Type Description route Object 页面配置 Source: navigate/History.js padStart(str, minLen, leadChar) 若字符串长度小于指定长度，则在前方拼接指定字符es6中string的padStart函数目前存在兼容性问题，暂以此替代 Parameters: Name Type Description str 字符串 minLen 指定长度 leadChar 指定字符 Source: operationKit.js Returns: 新字符串 Type string pageRestoreHandler(route, context) 页面数据恢复函数，用于 wepy实例覆盖问题，存在两级同路由页面时，前者数据会被后者覆盖，返回时需予以恢复，详见bug：两级页面为同一路由时，后者数据覆盖前者 无限层级路由策略中，层级过深时，新开页面会替换前一页面，导致前一页面数据丢失，返回时需予以恢复 Parameters: Name Type Description route object 页面路由对象 Properties Name Type Description url string 页面url，绝对路径 wxPage object 页面卸载前的原生页面实例拷贝 context string 数据丢失场景： tainted - 实例覆盖问题导致的数据丢失 | unloaded - 层级问题导致的数据丢失 Source: wepyKit.js Returns: 数据恢复是否成功，若成功，则恢复结束；若失败，则模块将继而尝试使用默认恢复策略 Type Object parseInlineStyle(styleStr) 将内联样式字符串解析为对象形式 Parameters: Name Type Description styleStr string 内联样式，e.g. 'color: red; transform: translate(20px, 30px)' Source: operationKit.js Returns: 内联样式对象，e.g. {color:\"red\",transform:\"translate(20px, 30px)\"} Type Object peerAssign(target, sources) 覆盖目标字段，剔除多余字段将源对象的值覆盖目标对象，相同结构相同参数部分直接覆盖，其它部分予以剔除 Parameters: Name Type Description target object 目标对象 sources object 若干个源对象 Source: operationKit.js Example //模块中指定的可配项列表及其默认值 const defaultOptions = { x: 1, y: {a: 1, b: 1} }; //调用方传入的自定义配置 let customOptions = { y: {a: 2}, //可能只指定了部分配置 zz: 2, //可能还含有一堆杂七杂八的属性 zzz: 2, }; //初始配置（target为空对象时，取source[0]作为蓝本，只保留sources[0]中的属性） let options = peerAssign({}, defaultOptions, customOptions); console.log('options:', options); //{x: 1, y: {a:2, b:1}} 所需属性予以覆盖，多余属性予以剔除 //增量配置（target不为空时，取target作为蓝本，只保留target中的属性） peerAssign(options, {x:3, y: {b:3}, zz:3}); console.log('options:', options); //{x: 3, y: {a:2, b:3}} &lt;async&gt; play() 开始播放视频 Source: RewardedVideoPlayer.js Returns: 播放结果 { code: 0, //是否正常：0-正常播放，其它-播放异常（微信版本过低/视频加载失败/其它异常情况） errMsg: '', //异常提示信息 isEnded: true, //（正常时）是否观看完整} Type Promise.&lt;Object&gt; queryRect(selector) 查询元素在页面中的坐标，单位：px Parameters: Name Type Description selector string 元素选择器 Source: operationKit.js Returns: 元素坐标 Type Promise.&lt;Object&gt; &lt;async&gt; redirectTo(route) 替换当前页面 Parameters: Name Type Description route Object 页面配置，格式同wx.redirectTo Source: navigate/Navigator.js registerPageHook(hook, handler) 注册全局页面钩子 Parameters: Name Type Description hook string 页面生命周期钩子名称 handler function 处理函数 注：页面中若有自定义同名钩子，则全局钩子会被覆盖，需要手动触发，如： 页面有自定义onUnload时需在onUnload中调用 super.onUnload &amp;&amp; super.onUnload(); Source: wepyKit.js registerToThis(lib|name, propMap|value) 注册全局this属性 Parameters: Name Type Description lib|name Object | string propMap|value Object | * e.g. registerToThis('$navigateTo', wx.navigateTo); registerToThis('$redirectTo', wx.redirectTo); registerToThis(wx, {'$navigateTo': 'navigateTo', '$redirectTo': 'redirectTo'}); 则所有页面&amp;组件可以以 this.$navigateTo 的形式调用 wx.navigateTo Source: wepyKit.js registerToThis(methodName, methodFunc) 在requester对象上注册方法，用于提供便捷调用e.g.注册requestWithLogin方法便于直接进行需要登录态的接口调用 Parameters: Name Type Description methodName string 方法名 methodFunc function 方法函数 Source: request/Requester.js replace(route) 替换当前页 Parameters: Name Type Description route Object 页面配置 Source: navigate/History.js &lt;async&gt; request(reqOptions [, manageOptions]) 发送请求，供外部调用 Parameters: Name Type Argument Description reqOptions Object manageOptions Object &lt;optional&gt; Source: request/Requester.js Returns: 成功时返回接口数据，失败时返回完整请求结果 Type Promise.&lt;(ReqRes|ReqRes.data)&gt; &lt;async&gt; requestWithLogin(reqOptions [, manageOptions]) http请求，封装了登录逻辑，保证调用接口时具有登录态 Parameters: Name Type Argument Description reqOptions Object 调用参数，格式同request Properties Name Type Description loginOpts Object 登录参数，格式同login manageOptions Object &lt;optional&gt; 管理参数，格式同request Source: request/plugin/LoginPlugin.js Returns: 请求结果，格式同request Type Promise requireConfig(target) 类修饰器，确保调用API时已完成项目信息配置 Parameters: Name Type Description target Source: login/BaseLogin.js resetRoute(route) 重置路由对象 Parameters: Name Type Description route Source: navigate/History.js savePage(idx, wxPage) 保存页面数据 Parameters: Name Type Description idx number 页面栈下标 wxPage object 原生页面实例 Source: navigate/History.js semanticRemainTime(remainMs, remainderInterval, topLevel) 剩余时间的语义化表示 Parameters: Name Type Description remainMs number 剩余时间，单位：毫秒 remainderInterval number 最小时间间隔，不足1秒的部分以此计数 topLevel string 顶层间隔：day|hour|minute|second， 如顶层间隔为'hour'，则返回结果为形如 27小时3分钟 而不是 1天3小时3分钟 Source: operationKit.js Returns: 剩余days天hours小时minutes分钟seconds秒remainderIntervals间隔 Type Object set(key, value [, options]) 写入指定cookie Parameters: Name Type Argument Description key string 要写入的key value string 要写入的value options object &lt;optional&gt; 配置选项（暂未支持） Source: Cookie.js setCookie(setStr) 写入cookie Parameters: Name Type Description setStr string 写入指令，格式形如：'key1=value1; path=/;'（类似web中document.cookie赋值） Source: Cookie.js silentLogin(loginOptions, configOptions) 静默登录可以在用户无感知的情况下后台悄悄完成的登录过程 Parameters: Name Type Description loginOptions Object 登录函数调用参数 configOptions Object 登录模块配置参数 Source: login/auth/BaseAuth.js Returns: Type Promise.&lt;{succeeded: boolean, errMsg: string, userInfo: {}, expireTime: number, anonymousInfo: {}}&gt; subscribe(eventType, handler, persistType) 监听指定事件 Parameters: Name Type Description eventType string 事件类型 handler function 监听函数 persistType string 持续策略：once-触发一次后自动移除 | always-每次都触发 Source: EventHub.js supportWXCallback(target, funcName, descriptor) 提供微信api形式的回调主要适用场景：将微信api改写为promise形式后，兼容旧代码被修饰函数应该返回一个promise，成功时resolve，失败时reject，或返回{succeeded: true/false, ...}格式，通过succeeded字段标识成功失败修饰后的函数会支持arguments[0]中传入success、fail、complete属性，并根据promise结果进行回调 Parameters: Name Type Description target funcName descriptor Source: decorator/compatible.js toAbsolutePath(relativePath, curPath) 将小程序相对路径转为绝对路径 Parameters: Name Type Description relativePath string 相对路径 curPath string 当前路径 Source: operationKit.js Returns: 绝对路径 Type string toInlineStyle(styleObj) 将样式对象转为内联样式字符串 Parameters: Name Type Description styleObj Object 内联样式对象，e.g. {color:\"red\",transform:\"translate(20px, 30px)\"} Source: operationKit.js Returns: 内联样式，e.g. 'color: red; transform: translate(20px, 30px)' Type string withErrToast(defaultMsg [, duration]) 捕获async函数中的异常，并进行错误提示函数正常结束时应 return 'ok'，return其它文案时将toast指定文案，无返回值或产生异常时将toast默认文案 Parameters: Name Type Argument Description defaultMsg string 默认文案 duration number &lt;optional&gt; 可选，toast持续时长 Source: decorator/errSafe.js &lt;async&gt; wxLogin() 微信登录：调用微信相关API，获取用户标识（openid，某些情况下也能获得unionid） Source: login/auth/WechatAuth.js Returns: 微信用户标识 Type Promise.&lt;Object&gt; Type Definitions ReqRes 接口请求结果 Type: Object Properties: Name Type Argument Description succeeded boolean 请求是否成功（服务器返回即算成功，包括404/500等，网络异常等导致请求未正常返回才算失败） data string | Object | Arraybuffer &lt;optional&gt; 开发者服务器返回的数据 statusCode number &lt;optional&gt; 开发者服务器返回的 HTTP 状态码 header Object &lt;optional&gt; 开发者服务器返回的 HTTP Response Header errMsg string &lt;optional&gt; 错误信息 Source: request/Requester.js × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Classes Classes BaseLogin exports exports exports exports exports exports RouteParams × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve fancy-mini小程序代码库，封装一些常用的功能模块和ui组件。开发过程使用wepy框架，对非wepy项目亦有一定程度兼容。 功能小程序能力搭建/增强 无限层级路由策略 问题：小程序原生页面存在层级限制，最多只能同时打开10层页面，超过10层时便会无法打开新页面 方案：自行维护完整历史记录，超出层级限制后在最后一层进行模拟导航，详见无限层级路由方案 使用：参见 无限层级路由模块使用说明 登录模块 功能：健壮高效的小程序登录机制，封装处理了拒绝授权、登录态过期、免并发、自定义弹窗、静默登录、场景适配、多端复用等，详见健壮高效的小程序登录方案 使用： 参见 登录模块使用说明 (working on branch: feature-login) cookie模块 问题：很多时候，后端现有接口是先前对接M页/APP开发的，可能会使用cookie进行参数获取/传递；但小程序不支持cookie，导致后端接口复用/多端兼容成本增高。 方案：利用前端存储，自行模拟&amp;管理cookie；封装接口调用过程，植入cookie逻辑。 使用： 待补充 ---- canvas工具集 功能：封装了一些常用的canvas操作，如图片居中裁剪、圆形头像、border-radius、多行文本、字符串过长截断/添加省略号等 使用：参见 canvasKit wx Promise化 问题：目前小程序API均以回调形式提供，当逻辑较为复杂时会造成回调函数层层嵌套，影响代码可读性和逻辑清晰性，且不利于并发时序控制 方案：将小程序API统一改造成Promise形式使用 使用：参见 Promise化的小程序API wxRefine 功能：对小程序部分API做自定义改造，以优化性能/满足特定需求，可与wxPromise、无限层级路由方案等结合使用，如：改造wx.getSystemInfo、wx.getLocation、wx.setStorage，引入缓存逻辑以优化性能 使用：待补充 ---- 渠道埋点策略 问题：需求中经常需要统计各个活动各个投放入口带来的流量和各步骤转化率，入口标识须层层传递，导致埋点过程繁琐，效率低下 方案：利用小程序存在APP级生命周期的特性，在打开小程序时记录流量来源，并自动携带到该次访问的所有页面的所有埋点中，使得渠道逻辑投放入口逻辑对埋点过程透明 使用： 待补充 ----- M页内嵌&amp;交互方案 功能：封装了小程序与小程序内嵌M页交互过程，并做了登录、支付、多端兼容等处理 使用： 待补充 ----- 跨页面传参 功能：后一页面向前一页面传参（如：发布页-分类列表页-选定分类-自动返回发布页，获取所选分类）、前一页面向后一页面传递大量数据（如：手机估价-卖掉换钱-发布页，获取并填充估价表单） 使用： 参见 跨页面传参使用示例 入口构造工具 功能：支持PM&amp;运营人员自助生成投放链接，支持FE&amp;QA自助开发/测试没有线上入口的新页面，详见小程序入口构造工具&amp;二维码测试工具 使用： 入口构造工具使用示例，组件源码 二维码测试工具 功能：支持扫码进入开发版/体验版小程序，便于测试二维码相关功能，详见小程序入口构造工具&amp;二维码测试工具 使用： 二维码测试工具使用示例，组件源码 激励视频播放器 功能：封装激励视频的加载、播放时序，使时序细节对外透明，便于调用；Promise化封装。 使用：RewardedVideoPlayer 小程序疑难杂症参考处理 toast长度截断问题 问题：原生toast内容超过7个汉字时会被截断无法展示完整，自定义toast又无法覆盖textarea、video等层级最高的原生组件 方案：根据内容长度自动选择合适的原生提示：带图标的原生toast、不带图标的原生toast、系统弹窗 使用：参见 不受长度限制、不受层级约束的原生toast textarea遮盖浮层问题 问题：textarea为原生组件层级最高，会遮盖价格填写蒙层、红包选择蒙层、绑定手机号提示框等各种普通浮层元素；特别是页面交互较复杂、浮层元素较多、出现时机较不确定时，难以有效规避。 方案：textarea处于编辑状态时使用原生textarea组件，处于非编辑状态时改用普通&lt;view&gt;元素展现内容 使用：参见 TextAreaEle 组件 小程序组件库 通用弹窗 功能：通用对话框，支持样式配置（单个/多个按钮、横版/竖版、带/不带关闭图标、带/不带顶部图标、自定义内联样式等）、按钮监听、按钮分享、按钮获取手机号、按钮异步处理结果统一返回等 使用： 参见 DialogCommon 组件 新手引导 功能：新手引导、新功能操作引导 特点： 就地高亮：引导蒙层中高亮区域即为页面中实际操作区域 就地交互：高亮区域可直接进行点击等交互 依次引导：展示引导蒙层-&gt;响应用户点击-&gt;等待交互完毕-&gt;展示下一个引导蒙层-&gt;... 公共逻辑抽离：公共逻辑统一封装，高亮元素只需进行少量配置，不必关注引导细节 使用： 使用说明、使用示例 待补充 ----- 实用工具函数 免并发修饰器 免并发 @noConcurrent功能：在上一次操作结果返回之前，不响应重复操作示例：用户连续多次点击同一个提交按钮，只响应一次，而不是同时提交多份表单使用：参见 @noConcurrent修饰器使用示例 步骤并合 @mergingStep功能：步骤并合，避免公共步骤重复执行示例： 页面内同时发生如下三个请求： 登录-发送接口A、登录-发送接口B、登录-发送接口C 未使用本修饰器时，网络时序：登录，登录，登录 - 接口A，接口B，接口C， 登录请求将会被发送三次 使用本修饰器时，网络时序：登录 - 接口A，接口B，接口C，登录请求只会被发送一次 使用：参见 @mergingStep修饰器使用示例 单通道执行 @singleAisle功能： 使得并发调用逐个顺序执行示例：页面中多处同时调用弹窗函数未使用本修饰器时，执行时序：弹窗1、弹窗2、弹窗3同时展现，用户同时看到多个弹窗堆在一起and/or弹窗相互覆盖使用本修饰器时，执行时序：弹窗1展现、等待交互、用户关闭 =&gt; 弹窗2展现、等待交互、用户关闭 =&gt; 弹窗3展现、等待交互、用户关闭，弹窗函数依次顺序执行使用：参见 @singleAisle修饰器使用示例 多函数互斥 @makeMutex功能： 多函数互斥免并发示例： 跳转相关函数navigateTo、navigateToMiniProgram、reLaunch等相互之间免并发使用：参见 @makeMutex修饰器 异常捕获修饰器 异常捕获 @errSafe功能：兼容函数异常示例：页面获取数据后交由各子函数进行解析，子函数数据解析异常应予以捕获，避免局部数据问题导致整个页面瘫痪使用： 参见 @errSafe修饰器 异常提示 @withErrToast功能： 兼容异常，响应交互示例： 页面操作响应过程，若出现异常应予以适当提示，避免交互无响应使用： 参见 @withErrToast修饰器 wepyKit 功能：wepy工具集，与wepy框架耦合度较高的功能在此模块中提供，如：注册全局this属性、注册全局页面钩子等 使用： 参见 wepyKit debugKit待补充 ----- operationKit待补充 ----- 待补充 ----- 效果演示 小程序名称：fancyDemos 访问： 源码：fancy-mini-demos （功能逐步补全中） 安装npm install --save fancy-mini 使用 - wepy项目 关于代码包大小为避免代码包膨胀，各模块没有合并导出，而是作为单独的文件各自引入，这样，只有项目中实际有引用的模块才会被打进小程序代码包中，无任何引用的部分不会影响小程序的代码包体积。 引用js模块 普通模块直接根据路径引入即可使用，如： import canvasKit from 'fancy-mini/lib/canvasKit'; //引入需要的模块 console.log('canvasKit:', canvasKit, 'canvasKit.fillText:', canvasKit.fillText); //使用该模块 复杂模块可能还需进行些许配置，具体参见模块各自的使用说明。 引用组件待补充 ---- 完整使用demo，参见 fancy-mini-demos（逐步补全中） 使用 - 非wepy项目 引用js模块js模块中与wepy框架耦合的部分均已抽离至wepyKit模块，并以配置的形式单独引入。非wepy项目引用方式可参考\"使用 - wepy项目\"小节，只是若配置过程中使用到了wepyKit模块，需自行实现wepyKit相关功能并予以替换。 引用组件本代码库组件部分均基于wepy框架开发，不直接支持非wepy项目，如有需要，请下载源码自行改造。 TODO 补全模块 补全文档 补全demo wpy-npm-workaround 目前wepy在引用包含多个组件的npm包时，存在bug： wepy 1.7.0以上 &amp;&amp; Mac环境，可以正常引用， 见issue：https://github.com/Tencent/wepy/issues/851 wepy 1.7.0以下 || Windows环境，无法正常引用， 见issue：https://github.com/Tencent/wepy/issues/1035 可直接拷贝至本地目录使用，但最好能提供更友好的引用方式 × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"BaseLogin.html":{"id":"BaseLogin.html","title":"Class: BaseLogin","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Class: BaseLogin BaseLogin 登录模块 new BaseLogin( [configOptions]) 构造函数 Parameters: Name Type Argument Description configOptions object &lt;optional&gt; 配置项，格式参见config函数 Source: login/BaseLogin.js Members userInfo 获取用户信息 Source: login/BaseLogin.js Methods &lt;protected&gt; _appendConfig(key, value) 追加配置项主要供子类调用，便于子类传递自定义配置项给自定义鉴权器/自定义钩子函数建议子类将所有自定义配置项封装成一个对象，总共占用一个key，避免未来和父类新增配置项命名冲突 Parameters: Name Type Description key string 配置项名称 value object | * 配置项值 Source: login/BaseLogin.js &lt;async&gt; _handleAddOn() 支持使用方配置自定义附加步骤，会在正常登录流程执行成功时调用，并根据其处理结果生成最终登录结果 Source: login/BaseLogin.js Returns: Type Promise.&lt;*&gt; &lt;async, protected&gt; _handleUserAuth(options) Parameters: Name Type Description options Source: login/BaseLogin.js Returns: 交互结果，格式形如： { succeeded: true, //是否成功 errMsg: '', //错误信息，调试用 authType: '', //用户选择的验证方式 authData: {}, //交互数据，格式由该验证方式对应的鉴权器指定 } Type Promise.&lt;{succeeded: boolean, errMsg: string, authType: string, authData: {}}&gt; &lt;protected&gt; _init() 初始化 Source: login/BaseLogin.js checkLogin() 检查是否登录 Source: login/BaseLogin.js Returns: 是否登录 Type boolean clearLogin(needClearAuth) 清除前端登录态 Parameters: Name Type Description needClearAuth boolean 是否需要清除鉴权信息：false-仅清除登录态，下次还可以静默登录 | true-同时清除鉴权信息，下次必须授权登录 Source: login/BaseLogin.js config(configOptions) 模块配置 Parameters: Name Type Description configOptions Object Properties Name Type Argument Description loginInfoStorage String &lt;optional&gt; 登录相关信息存储到storage时使用的key requester Requester 请求管理器，为Requester对象（参见/src/request/Requester） onUserAuthFailed function &lt;optional&gt; 钩子函数，获取用户授权信息失败时触发 onUserAuthSucceeded function &lt;optional&gt; 钩子函数，获取用户授权信息成功时触发 onNewlyLogin function &lt;optional&gt; 钩子函数，刚刚登录成功时触发（未登录=&gt;已登录） onLoginFailed function &lt;optional&gt; 钩子函数，登录失败时触发 入参： 参数0：登录结果，格式形如：{ code: 0, //状态码，0为成功，其它为失败 errMsg:'login api failed...', //详细错误日志，debug用 toastMsg: '您的账号存在安全风险，请联系客服进行处理' //（若有）用户话术，提示失败原因 } 参数1：选项，格式形如：{ failAction: 'auto', //调用方希望的失败处理方式：auto-自动处理 | none-调用方自行处理 | 其它约定值 } authEngineMap Object 鉴权器映射表 key为登录方式，value为对应的鉴权器（BaseAuth对象，参见/src/login/auth/BaseAuth） e.g. { 'wechat' : new WechatAuth(), //微信登录，WechatAuth应继承于BaseAuth 'phone' : new PhoneAuth(), //手机号登录，PhoneAuth应继承于BaseAuth } defaultAuthType String 默认登录方式 userAuthHandler function 授权交互处理函数（async），负责跟用户交互，收集鉴权所需信息 入参：无 返回值：形如 { succeeded: true, //是否成功 errMsg: '', //错误信息，调试用 authType: '', //用户选择的登录方式 authData: {}, //交互数据，格式由该登录方式对应的鉴权器指定 } loginStepAddOn function &lt;optional&gt; 登录流程自定义附加步骤，为一个async函数，会在正常登录流程执行成功时调用，并根据其处理结果生成最终登录结果 入参：无 处理结果，格式形如：{ succeeded: true, //是否成功 errMsg:'login api failed...', //详细失败原因，debug用 toastMsg: '您的账号存在安全风险，请联系客服进行处理' //（若有）用户话术，提示失败原因 } Source: login/BaseLogin.js &lt;async&gt; login( [options]) 登录 Parameters: Name Type Argument Description options Object &lt;optional&gt; 登录选项 Properties Name Type Argument Description callback function &lt;optional&gt; 兼容起见支持回调，但更建议以Promise方式使用 mode string &lt;optional&gt; 登录模式 common - 通用模式，适合大部分页面场景 silent - 静默模式，适合免打扰场景：只尝试静默登录，不触发授权弹窗；不管成功失败都不影响页面功能和后续接口调用 force - 强制模式，刷新登录态 forceSilent - 强制静默登录，对老用户，刷新登录态；对新用户，不触发授权 forceAuth - 强制授权登录，强制展示授权界面 userAuthHandler function &lt;optional&gt; 自定义用户授权交互 failAction String &lt;optional&gt; 失败处理方式：auto-自动处理 | none-调用方自行处理 | 其它-和onLoginFailed钩子函数约定的其它处理方式 thisIssuer Object &lt;optional&gt; 触发登录的组件的this对象，供钩子函数使用 Source: login/BaseLogin.js Returns: res 登录结果，格式形如：{ code: 0, //状态码，0为成功，其它为失败 errMsg:'login api failed...', //详细错误日志，debug用 toastMsg: '您的账号存在安全风险，请联系客服进行处理' //（若有）用户话术，提示失败原因 } code: -100 用户交互失败 e.g.用户拒绝授权等 -200 静默模式登录失败 -300 授权登录失败 -400 附加步骤返回失败结果 -500 模块内部异常 Type Promise.&lt;Object&gt; logout(needClearAuth) 退出登录 Parameters: Name Type Description needClearAuth boolean 是否需要清除鉴权信息：false-仅清除登录态，下次还可以静默登录 | true-同时清除鉴权信息，下次必须授权登录 Source: login/BaseLogin.js Returns: res 退出登录结果，格式形如：{code:0, errMsg:'ok'} Type Object makeAssignableMethod(methodName) 将方法封装为通用函数，使之可以在任意this对象上执行 Parameters: Name Type Description methodName String 方法名 Source: login/BaseLogin.js Returns: 封装后的函数 Type function &lt;async&gt; reLogin() 重新登录 Source: login/BaseLogin.js Returns: 登录结果，格式同login Type Object × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"module.exports.html":{"id":"module.exports.html","title":"Class: exports","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Class: exports exports 导航器由于小程序只支持最多5级页面（后放宽至10级），但需求上希望维护更长的历史栈，故自行维护完整历史栈并改写默认导航操作使用：详见 docs/无限层级路由方案.md new exports() Source: navigate/Navigator.js Methods &lt;static&gt; aspectFill(ctx, picFile, picInfo, x, y, w, h, bgColor) 绘制图片，保持宽高比居中裁剪，短边完全展示，长边居中截取 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 picFile 图片临时文件路径 picInfo wx.getImageInfo返回的图片原始信息 x 左上角横坐标 y 左上角纵坐标 w 宽度 h 高度 bgColor 背景色，裁剪后多余部分用背景色擦除说明： 1.应先绘制图片，后填充图片周边内容，否则图片周边长边方向内容可能会被部分擦除 2.在开发者工具上图片多余部分无法被清除，但在真机上正常 Source: canvasKit.js &lt;static&gt; borderRadius(ctx, x, y, w, h, radius, bgColor) 将矩形切成圆角矩形 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 矩形左上角横坐标 y 矩形左上角纵坐标 w 矩形宽度 h 矩形高度 radius 圆角半径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; ellipsisStr(str, len, ellipsis) 字符串过长截断，1个字母长度计为1,1个汉字长度计为2 Parameters: Name Type Description str string 原字符串 len number 最大长度 ellipsis boolean 过长时截断后是否加'...' Source: canvasKit.js Returns: 截断后字符串 Type string &lt;static&gt; fillText(ctx, text, x, y, fontSize, color, lineHeight, textAlign) 绘制文本，支持\\n换行 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 text 文本内容，支持\\n换行 x 文本区域（含行高）左上角横坐标；居中对齐时，改取中点横坐标 y 文本区域（含行高）左上角纵坐标 fontSize 字号，单位：px color 颜色 lineHeight 行高 textAlign 水平对齐方式，支持'left'、'center'，其它值没试过 Source: canvasKit.js &lt;static&gt; rounded(ctx, x, y, w, bgColor) 将方形区域切成圆形，场景示例：将头像切成圆形展示 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 左上角横坐标 y 左上角纵坐标 w 宽度/高度/圆的直径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; strLenGraphic() 字符串长度，1个字母长度计为1,1个汉字长度计为2canvas目前似乎不支持获取文本绘制后所占宽度，只能根据字数粗略计算了 Source: canvasKit.js Class: exports exports 激励视频播放器，封装激励视频加载、播放时序使用： 初始化：this.rewardedVideoPlayer = new RewardedVideoPlayer({adUnitId: '广告位id'}) 监听页面onShow: onShow(){ this.rewardedVideoPlayer.handlePageChange() }; 播放视频： let playRes = await this.rewardedVideoPlayer.play(); if (playRes.code !== 0) { //播放异常（微信版本过低/视频加载失败/其它异常情况） wx.showToast({ title: playRes.errMsg }) } else if (!playRes.isEnded) { //用户提前关闭视频 ; } else { //正常完整观看 ; }更多用法详见各函数注释 new exports(adUnitId) 构造函数 Parameters: Name Type Description adUnitId string 广告位id Source: RewardedVideoPlayer.js Methods &lt;static&gt; aspectFill(ctx, picFile, picInfo, x, y, w, h, bgColor) 绘制图片，保持宽高比居中裁剪，短边完全展示，长边居中截取 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 picFile 图片临时文件路径 picInfo wx.getImageInfo返回的图片原始信息 x 左上角横坐标 y 左上角纵坐标 w 宽度 h 高度 bgColor 背景色，裁剪后多余部分用背景色擦除说明： 1.应先绘制图片，后填充图片周边内容，否则图片周边长边方向内容可能会被部分擦除 2.在开发者工具上图片多余部分无法被清除，但在真机上正常 Source: canvasKit.js &lt;static&gt; borderRadius(ctx, x, y, w, h, radius, bgColor) 将矩形切成圆角矩形 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 矩形左上角横坐标 y 矩形左上角纵坐标 w 矩形宽度 h 矩形高度 radius 圆角半径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; ellipsisStr(str, len, ellipsis) 字符串过长截断，1个字母长度计为1,1个汉字长度计为2 Parameters: Name Type Description str string 原字符串 len number 最大长度 ellipsis boolean 过长时截断后是否加'...' Source: canvasKit.js Returns: 截断后字符串 Type string &lt;static&gt; fillText(ctx, text, x, y, fontSize, color, lineHeight, textAlign) 绘制文本，支持\\n换行 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 text 文本内容，支持\\n换行 x 文本区域（含行高）左上角横坐标；居中对齐时，改取中点横坐标 y 文本区域（含行高）左上角纵坐标 fontSize 字号，单位：px color 颜色 lineHeight 行高 textAlign 水平对齐方式，支持'left'、'center'，其它值没试过 Source: canvasKit.js &lt;static&gt; rounded(ctx, x, y, w, bgColor) 将方形区域切成圆形，场景示例：将头像切成圆形展示 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 左上角横坐标 y 左上角纵坐标 w 宽度/高度/圆的直径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; strLenGraphic() 字符串长度，1个字母长度计为1,1个汉字长度计为2canvas目前似乎不支持获取文本绘制后所占宽度，只能根据字数粗略计算了 Source: canvasKit.js Class: exports exports 历史记录由于小程序只支持最多5级页面，但需求上希望维护更长的历史栈，故自行维护完整历史记录 new exports() Source: navigate/History.js Methods &lt;static&gt; aspectFill(ctx, picFile, picInfo, x, y, w, h, bgColor) 绘制图片，保持宽高比居中裁剪，短边完全展示，长边居中截取 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 picFile 图片临时文件路径 picInfo wx.getImageInfo返回的图片原始信息 x 左上角横坐标 y 左上角纵坐标 w 宽度 h 高度 bgColor 背景色，裁剪后多余部分用背景色擦除说明： 1.应先绘制图片，后填充图片周边内容，否则图片周边长边方向内容可能会被部分擦除 2.在开发者工具上图片多余部分无法被清除，但在真机上正常 Source: canvasKit.js &lt;static&gt; borderRadius(ctx, x, y, w, h, radius, bgColor) 将矩形切成圆角矩形 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 矩形左上角横坐标 y 矩形左上角纵坐标 w 矩形宽度 h 矩形高度 radius 圆角半径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; ellipsisStr(str, len, ellipsis) 字符串过长截断，1个字母长度计为1,1个汉字长度计为2 Parameters: Name Type Description str string 原字符串 len number 最大长度 ellipsis boolean 过长时截断后是否加'...' Source: canvasKit.js Returns: 截断后字符串 Type string &lt;static&gt; fillText(ctx, text, x, y, fontSize, color, lineHeight, textAlign) 绘制文本，支持\\n换行 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 text 文本内容，支持\\n换行 x 文本区域（含行高）左上角横坐标；居中对齐时，改取中点横坐标 y 文本区域（含行高）左上角纵坐标 fontSize 字号，单位：px color 颜色 lineHeight 行高 textAlign 水平对齐方式，支持'left'、'center'，其它值没试过 Source: canvasKit.js &lt;static&gt; rounded(ctx, x, y, w, bgColor) 将方形区域切成圆形，场景示例：将头像切成圆形展示 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 左上角横坐标 y 左上角纵坐标 w 宽度/高度/圆的直径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; strLenGraphic() 字符串长度，1个字母长度计为1,1个汉字长度计为2canvas目前似乎不支持获取文本绘制后所占宽度，只能根据字数粗略计算了 Source: canvasKit.js Class: exports exports cookie管理器利用前端存储，模拟实现web中的cookie逻辑很多时候，后端现有接口是先前对接M页/APP开发的，可能会使用cookie进行参数获取/传递；但小程序不支持cookie，导致后端接口复用/多端兼容成本增高。利用本cookie管理器，结合./request/plugin/CookiePlugin中的cookie插件，可以在接口调用前后，自动植入cookie逻辑，便于小程序端复用cookie相关逻辑。 注：目前仅支持基础的取值赋值操作，domain、path、expires等各种配置选项暂未支持，会予以忽略 new exports(cookieStorageName) 构造函数 Parameters: Name Type Description cookieStorageName string cookie相关信息存储到storage时使用的key Source: Cookie.js Methods &lt;static&gt; aspectFill(ctx, picFile, picInfo, x, y, w, h, bgColor) 绘制图片，保持宽高比居中裁剪，短边完全展示，长边居中截取 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 picFile 图片临时文件路径 picInfo wx.getImageInfo返回的图片原始信息 x 左上角横坐标 y 左上角纵坐标 w 宽度 h 高度 bgColor 背景色，裁剪后多余部分用背景色擦除说明： 1.应先绘制图片，后填充图片周边内容，否则图片周边长边方向内容可能会被部分擦除 2.在开发者工具上图片多余部分无法被清除，但在真机上正常 Source: canvasKit.js &lt;static&gt; borderRadius(ctx, x, y, w, h, radius, bgColor) 将矩形切成圆角矩形 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 矩形左上角横坐标 y 矩形左上角纵坐标 w 矩形宽度 h 矩形高度 radius 圆角半径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; ellipsisStr(str, len, ellipsis) 字符串过长截断，1个字母长度计为1,1个汉字长度计为2 Parameters: Name Type Description str string 原字符串 len number 最大长度 ellipsis boolean 过长时截断后是否加'...' Source: canvasKit.js Returns: 截断后字符串 Type string &lt;static&gt; fillText(ctx, text, x, y, fontSize, color, lineHeight, textAlign) 绘制文本，支持\\n换行 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 text 文本内容，支持\\n换行 x 文本区域（含行高）左上角横坐标；居中对齐时，改取中点横坐标 y 文本区域（含行高）左上角纵坐标 fontSize 字号，单位：px color 颜色 lineHeight 行高 textAlign 水平对齐方式，支持'left'、'center'，其它值没试过 Source: canvasKit.js &lt;static&gt; rounded(ctx, x, y, w, bgColor) 将方形区域切成圆形，场景示例：将头像切成圆形展示 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 左上角横坐标 y 左上角纵坐标 w 宽度/高度/圆的直径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; strLenGraphic() 字符串长度，1个字母长度计为1,1个汉字长度计为2canvas目前似乎不支持获取文本绘制后所占宽度，只能根据字数粗略计算了 Source: canvasKit.js Class: exports exports 事件中心，用于跨组件/跨页面事件通信 new exports(validEvents) 构造函数 Parameters: Name Type Description validEvents Array.&lt;string&gt; 配置的事件列表 Source: EventHub.js Methods &lt;static&gt; aspectFill(ctx, picFile, picInfo, x, y, w, h, bgColor) 绘制图片，保持宽高比居中裁剪，短边完全展示，长边居中截取 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 picFile 图片临时文件路径 picInfo wx.getImageInfo返回的图片原始信息 x 左上角横坐标 y 左上角纵坐标 w 宽度 h 高度 bgColor 背景色，裁剪后多余部分用背景色擦除说明： 1.应先绘制图片，后填充图片周边内容，否则图片周边长边方向内容可能会被部分擦除 2.在开发者工具上图片多余部分无法被清除，但在真机上正常 Source: canvasKit.js &lt;static&gt; borderRadius(ctx, x, y, w, h, radius, bgColor) 将矩形切成圆角矩形 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 矩形左上角横坐标 y 矩形左上角纵坐标 w 矩形宽度 h 矩形高度 radius 圆角半径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; ellipsisStr(str, len, ellipsis) 字符串过长截断，1个字母长度计为1,1个汉字长度计为2 Parameters: Name Type Description str string 原字符串 len number 最大长度 ellipsis boolean 过长时截断后是否加'...' Source: canvasKit.js Returns: 截断后字符串 Type string &lt;static&gt; fillText(ctx, text, x, y, fontSize, color, lineHeight, textAlign) 绘制文本，支持\\n换行 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 text 文本内容，支持\\n换行 x 文本区域（含行高）左上角横坐标；居中对齐时，改取中点横坐标 y 文本区域（含行高）左上角纵坐标 fontSize 字号，单位：px color 颜色 lineHeight 行高 textAlign 水平对齐方式，支持'left'、'center'，其它值没试过 Source: canvasKit.js &lt;static&gt; rounded(ctx, x, y, w, bgColor) 将方形区域切成圆形，场景示例：将头像切成圆形展示 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 左上角横坐标 y 左上角纵坐标 w 宽度/高度/圆的直径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; strLenGraphic() 字符串长度，1个字母长度计为1,1个汉字长度计为2canvas目前似乎不支持获取文本绘制后所占宽度，只能根据字数粗略计算了 Source: canvasKit.js Class: exports exports 请求管理器，负责对接口请求进行各种封装处理 new exports( [configOptions]) 构造函数 Parameters: Name Type Argument Description configOptions Object &lt;optional&gt; Source: request/Requester.js Methods &lt;static&gt; aspectFill(ctx, picFile, picInfo, x, y, w, h, bgColor) 绘制图片，保持宽高比居中裁剪，短边完全展示，长边居中截取 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 picFile 图片临时文件路径 picInfo wx.getImageInfo返回的图片原始信息 x 左上角横坐标 y 左上角纵坐标 w 宽度 h 高度 bgColor 背景色，裁剪后多余部分用背景色擦除说明： 1.应先绘制图片，后填充图片周边内容，否则图片周边长边方向内容可能会被部分擦除 2.在开发者工具上图片多余部分无法被清除，但在真机上正常 Source: canvasKit.js &lt;static&gt; borderRadius(ctx, x, y, w, h, radius, bgColor) 将矩形切成圆角矩形 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 矩形左上角横坐标 y 矩形左上角纵坐标 w 矩形宽度 h 矩形高度 radius 圆角半径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; ellipsisStr(str, len, ellipsis) 字符串过长截断，1个字母长度计为1,1个汉字长度计为2 Parameters: Name Type Description str string 原字符串 len number 最大长度 ellipsis boolean 过长时截断后是否加'...' Source: canvasKit.js Returns: 截断后字符串 Type string &lt;static&gt; fillText(ctx, text, x, y, fontSize, color, lineHeight, textAlign) 绘制文本，支持\\n换行 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 text 文本内容，支持\\n换行 x 文本区域（含行高）左上角横坐标；居中对齐时，改取中点横坐标 y 文本区域（含行高）左上角纵坐标 fontSize 字号，单位：px color 颜色 lineHeight 行高 textAlign 水平对齐方式，支持'left'、'center'，其它值没试过 Source: canvasKit.js &lt;static&gt; rounded(ctx, x, y, w, bgColor) 将方形区域切成圆形，场景示例：将头像切成圆形展示 Parameters: Name Type Description ctx wx.createCanvasContext返回的canvas绘图上下文 x 左上角横坐标 y 左上角纵坐标 w 宽度/高度/圆的直径 bgColor 背景色，擦除部分以背景色填充 Source: canvasKit.js &lt;static&gt; strLenGraphic() 字符串长度，1个字母长度计为1,1个汉字长度计为2canvas目前似乎不支持获取文本绘制后所占宽度，只能根据字数粗略计算了 Source: canvasKit.js × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "},"RouteParams.html":{"id":"RouteParams.html","title":"Class: RouteParams","body":" fancy-mini Classes BaseLoginmodule.exportsRouteParams Global afterRequestafterRequestAsyncappendUrlParamauthLoginbackbeforeAuthLoginbeforeRequestbeforeRequestAsynccompareVersionconfigcookieObjToStrcookieStrToObjcorrectLevelctxDependConsolecurRoutecustomWxPromisifydataRestoreWx2WepydeepAssigndeepClonedeepEqualdelaydoCorrectionerrSafefullUrlgetgetCookiehandlePageChangehistoryisNonEmptyObjectisNonNullObjectisSamePagelengthlistenersloadloadStatemakeAssignableMethodmakeMutexmakeNoConcurrentmergeCookieStrmergingStepmountnavigateBacknavigateToNavRefinenoConcurrentnotifyonLoadStateChangeonPageUnloadopenpadStartpageRestoreHandlerparseInlineStylepeerAssignplayqueryRectredirectToregisterPageHookregisterToThisreplacerequestrequestWithLoginrequireConfigresetRouteroutessavePagesemanticRemainTimesetsetCookiesilentLoginsingleAislesubscribesupportWXCallbacktoAbsolutePathtoInlineStylewithErrToastwxLoginwxPromisewxResolve Class: RouteParams RouteParams 用于页面间传递参数场景一： 后一页面返回数据给前一页面，如：A页面-点击“选择地址”-地址页-选择完毕返回A页面，此时需将选择结果传给A页面场景二： 前一页面传递参数给后一页面，一般直接在url中加参数即可，但若数据复杂，亦可考虑使用此数据对象进行传递利用ES6导出的是符号连接特性，不同页面引入的是同一实例，A页面对数据进行操作，B页面即时生效，因而可当作全局数据对象使用相比于使用storage传参，此方式为内存操作，即时性更强，效率更高相比于直接调用前一页面的指定成员方法，此方式更通用，页面间耦合性更低 new RouteParams() Source: routeParams.js Methods clearBackFrom() 清除后一页面向前一页面的传递内容 Source: routeParams.js clearOpenFrom() 清除前一页面向后一页面的传递内容 Source: routeParams.js getBackFromData() 返回前一页面时，获取后一页面传递过来的数据 Source: routeParams.js Returns: 后一页面传递过来的数据 Type string getBackFromRoute() 返回前一页面时，获取后一页面的页面路径 Source: routeParams.js Returns: 后一页面页面路径 Type string getOpenFromData() 进到后一页面时，获取前一页面传递过来的数据 Source: routeParams.js Returns: 前一页面传递过来的数据 Type string getOpenFromRoute() 进到后一页面时，获取前一页面的页面路径 Source: routeParams.js Returns: 前一页面页面路径 Type string setBackFromData(data) 后一页面向前一页面传递数据 Parameters: Name Type Description data * 数据内容 Source: routeParams.js setOpenFromData(data) 前一页面向后一页面传递数据 Parameters: Name Type Description data * 数据内容 Source: routeParams.js × Search results Close Documentation generated by JSDoc 3.5.5 on Tue Nov 12th 2019 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
